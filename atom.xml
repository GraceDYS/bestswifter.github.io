<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全栈养成计划</title>
  <subtitle>每天学点新知识~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fullstack.blog/"/>
  <updated>2017-06-25T15:36:47.000Z</updated>
  <id>http://fullstack.blog/</id>
  
  <author>
    <name>Fullstack</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大前端开发者需要了解的基础编译原理和语言知识</title>
    <link href="http://fullstack.blog/2017/06/24/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://fullstack.blog/2017/06/24/大前端开发者需要了解的基础编译原理和语言知识/</id>
    <published>2017-06-24T14:03:39.000Z</published>
    <updated>2017-06-25T15:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我刚刚进入大学，从零开始学习 C 语言的时候，我就不断的从学长的口中听到一个又一个语言，比如 C++、Java、Python、JavaScript 这些大众的，也有 Lisp、Perl、Ruby 这些相对小众的。一般来说，当程序员讨论一门语言的时候，默认的上下文经常是:“用 xxx 语言来完成 xxx 任务”。所以一直困扰着的我的一个问题就是，为什么完成某个任务，一定要选择特定的语言，比如安卓开发是 Java，前端要用 JavaScript，iOS 开发使用 Objective-C 或者 Swift。这些问题的答案非常复杂，有的是技术原因，有的是历史原因，有的会考虑成本，很难得出统一的结论，只能 case-by-case 的分析。这篇文章并非专门解答上述问题，而是希望通过介绍一些通用的概念，帮助读者掌握分析问题的能力，如果这个概念在实际编程中用得到，我也会举一些具体的例子。</p>
<p>在阅读本文前，不妨思考一下这几个问题，如果没有头绪，建议看完文章以后再思考一遍。如果觉得答案显而易见，恭喜你，这篇文章并非为你准备的:</p>
<ol>
<li>什么是编译器，它以什么为分界线，分为前端和后端？</li>
<li>Java 是编译型语言还是解释型语言，Python 呢？</li>
<li>C 语言的编译器也是 C 语言，那它怎么被编译的？</li>
<li>目标文件的格式是什么样的，段表、符号表、重定位表有什么作用？</li>
<li>Swift 是静态语言，为什么还有运行时库？</li>
<li>什么是 ABI，ABI 不稳定有什么问题？</li>
<li>什么是 WebAssembly，为什么要推出这门技术，用 C++ 代替 JavaScript 可行么？</li>
<li>JavaScript 和 DOM API 是什么关系，JavaScript 可以读写文件么？</li>
<li>C++ 代码可以自动转换成 Java 代码么，任意两种语言是否可以互转？</li>
<li>为什么说 Python 是胶水语言，它可以用来开发 iOS/Android 么？</li>
</ol>
<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>就像数学是一个公理体系，从简单的公理就能推导出各种高阶公式一样，我们从最基本的 C 语言和编译说起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="built_in">strlen</span>(<span class="string">"Hello world"</span>);  <span class="comment">// 字符串的长度是 11</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关的介绍编译过程的文章很多，读者应该都非常熟悉了，整个流程包括<strong>预处理</strong>、<strong>词法分析</strong>、<strong>语法分析</strong>、<strong>生成中间代码</strong>，<strong>生成目标代码</strong>，<strong>汇编</strong>，<strong>链接</strong> 等。已有的文章大多分析了每一步的逻辑，但很少谈实现思路，我会尽量用简单的语言来描述每一步的实现思路，相信这样有助于加深记忆。由于主要谈的概念和思路，难免会有一些不够准确的抽象，读者学会抓重点就行。</p>
<p>预处理是一个独立的模块，它放在最后介绍，我们先看词法分析。</p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>最先登场的是编译器，它负责前五个步骤，也就是说编译器的输入是源代码，输出是中间代码。</p>
<p>编译器不能像人一样，一眼就看明白源代码的内容，它只能比较傻的逐个单词分析。词法分析要做的就是把源代码分割开，形成若干个单词。这个过程并不像想象的那么简单。比如举几个例子:</p>
<ol>
<li><code>int t</code> 表示一个整数，而 <code>intt</code>  只是一个变量名。</li>
<li><code>int a()</code> 表示一个函数而非整数 a，<code>int a ()</code> 也是一个函数。</li>
<li><code>a =</code> 没有具体价值，它可以是一个赋值语句，还可以是 <code>a == 1</code> 的前缀，表示一个判断。</li>
</ol>
<p>词法分析的主要难点在于，前缀无法决定一个完整字符串的含义，通常需要看完整句以后才知道每个单词的具体含义。同时，C 语言的语法也不简单，各种关键字，括号，逗号，语法等等都会给词法分析的实现增加难度。</p>
<p>词法分析的主要实现原理是状态机，它逐个读取字符，然后根据读到的字符的特点转换状态。比如这是 GCC 的词法分析状态机(引用自《编译系统透视》):</p>
<p><img src="http://images.bestswifter.com/1497792598.png" alt=""></p>
<p>如果自己实现的话，思路也不难。外面包一个循环，然后各种 <code>switch...case</code> 就完事了。词法分析应该算是最简单的一节。</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>经过词法分析以后，编译器已经知道了每个单词，但这些单词组合起来表示的语法还不清楚。一个简单的思路是模板匹配，比如有这样的语句:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>它其实表示了这么一种通用的语法格式:</p>
<blockquote>
<p>类型 变量名 = 常量;</p>
</blockquote>
<p>所以 <code>int a = 10;</code> 当然可以匹配上这种模式。同理，它不可能匹配 <code>类型 函数名(参数);</code> 这种函数定义模式，因为两者结构不一致，等号无法被匹配。</p>
<p>语法分析比词法分析更复杂，因为所有 C 语言支持的语法特性都必须被语法分析器正确的匹配，这个难度比纯新手学习 C 语言语法难上很多倍。不过这个属于业务复杂性，无论采用哪种解决方案都不可避免，因为语法规则的数量就是这么多。</p>
<p>在匹配模式的时候，另一个问题在于上述的名词，比如 <strong>类型</strong>、<strong>参数</strong>，很难界定。比如 <code>int</code> 是类型，<code>long long</code> 也是类型，<code>unsigned long long</code> 也是类型。<code>(int a)</code> 可以是参数，<code>(int a, int b)</code> 也是参数，<code>(unsigned long long a, long long double b, int *p)</code> 看起来能把人逼疯。</p>
<p>下面举一个简单的例子来解释 <code>int a = 10</code> 是如何被解析的，总的思路是归纳与分解。我们把一个复杂的式子分割成若干部分，然后分析各个部分，这样可以简化复杂度。对于 <code>int a = 10</code> 来说，他是一个声明，声明由两部分组成，分别是声明说明符和初始声明符列表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">声明</th>
<th style="text-align:center">声明说明符</th>
<th style="text-align:center">初始声明符列表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int a = 10</td>
<td style="text-align:center">int</td>
<td style="text-align:center">a = 10</td>
</tr>
<tr>
<td style="text-align:left">int fun(int a)</td>
<td style="text-align:center">int</td>
<td style="text-align:center">fun(int a)</td>
</tr>
<tr>
<td style="text-align:left">int array[5]</td>
<td style="text-align:center">int</td>
<td style="text-align:center">array[5]</td>
</tr>
</tbody>
</table>
<p>声明说明符比较简单，它其实是若干个类型的串联:</p>
<blockquote>
<p>声明说明符 = 类型 + 类型的数组(长度可以为 0)</p>
</blockquote>
<p>而且我们知道若干个类型连在一起又变成了声明说明符，所以上述等式等价于:</p>
<blockquote>
<p>声明说明符 = 类型 + 声明说明符(可选)</p>
</blockquote>
<p>再严谨一些，声明说明符还可以包括 <code>const</code> 这样的限定说明符，<code>inline</code> 这样的函数说明符，和 <code>_Alignas</code> 这样的对齐说明符。借用书中的公式，它的完整表达如下:</p>
<p><img src="http://images.bestswifter.com/1497794113.png" alt=""></p>
<p>这才仅仅是声明语句中最简单的声明说明符，仅仅是几个类型和关键字的组合而已。后面的<strong>初始声明符列表</strong>的解析更复杂。如果有能力做完这些解析，恭喜你，成功的解析了声明语句。你会发现什么定义语句啦，调用语句啦，正妩媚的向你招手╮(╯▽╰)╭。</p>
<p>成功解析语法以后，我们会得到抽象语法树(AST: Abstract Syntax Tree)。以这段代码为例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line">    c = a + b;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的语法树如下:</p>
<p><img src="http://images.bestswifter.com/1497794686.png" alt=""></p>
<p>语法树将字符串格式的源代码转化为树状的数据结构，更容易被计算机理解和处理。但它距离中间代码还有一定的距离。</p>
<h2 id="生成中间代码"><a href="#生成中间代码" class="headerlink" title="生成中间代码"></a>生成中间代码</h2><p>以 GCC 为例，生成中间代码可以分为三个步骤:</p>
<ol>
<li>语法树转高端 gimple</li>
<li>高端 gimple 转低端 gimple</li>
<li>低端 gimple 经过 cfa 转 ssa 再转中间代码</li>
</ol>
<p>简单的介绍一下每一步都做了什么。</p>
<h3 id="语法树转高端-gimple"><a href="#语法树转高端-gimple" class="headerlink" title="语法树转高端 gimple"></a>语法树转高端 gimple</h3><p>这一步主要是处理寄存器和栈，比如 <code>c = a + b</code> 并没有直接的汇编代码和它对应，一般来说需要把 <code>a + b</code> 的结果保存到寄存器中，然后再把寄存器赋值给 c。所以这一步如果用 C 语言来表示其实是: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> temp = a + b; <span class="comment">// temp 其实是寄存器</span></div><div class="line">c =  temp;</div></pre></td></tr></table></figure>
<p>另外，调用一个新的函数时会进入到函数自己的栈，建栈的操作也需要在 gimple 中声明。</p>
<h3 id="高端-gimple-转低端-gimple"><a href="#高端-gimple-转低端-gimple" class="headerlink" title="高端 gimple 转低端 gimple"></a>高端 gimple 转低端 gimple</h3><p>这一步主要是把变量定义，语句执行和返回语句区分存储。比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">a++;</div><div class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>会被处理成:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</div><div class="line">a++;</div></pre></td></tr></table></figure>
<p>这样做的好处是很容易计算一个函数到底需要多少栈空间。</p>
<p>此外，<code>return</code> 语句会被统一处理，放在函数的末尾，比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会被处理成:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">goto</span> a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">goto</span> b;</div><div class="line">&#125;</div><div class="line">a:</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">b:</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure>
<h3 id="低端-gimple-经过-cfa-转-ssa-再转中间代码"><a href="#低端-gimple-经过-cfa-转-ssa-再转中间代码" class="headerlink" title="低端 gimple 经过 cfa 转 ssa 再转中间代码"></a>低端 gimple 经过 cfa 转 ssa 再转中间代码</h3><p>这一步主要是进行各种优化，添加版本号等，我不太了解，对于普通开发者来说也没有学习的必要。</p>
<h3 id="中间代码的意义"><a href="#中间代码的意义" class="headerlink" title="中间代码的意义"></a>中间代码的意义</h3><p>其实中间代码可以被省略，抽象语法树可以直接转化为目标代码(汇编代码)。然而，不同的 CPU 的汇编语法并不一致，比如 <a href="http://blog.csdn.net/wusuopubupt/article/details/26378845" target="_blank" rel="external">AT&amp;T与Intel汇编风格比较</a> 这篇文章所提到的，Intel 架构和 AT&amp;T 架构的汇编码中，源操作数和目标操作数位置恰好相反。Intel 架构下操作数和立即数没有前缀但 AT&amp;T 有。因此一种比较高效的做法是先生成语言无关，CPU 也无关的中间代码，然后再生成对应各个 CPU 的汇编代码。</p>
<p>生成中间代码是非常重要的一步，一方面它和语言无关，也和 CPU 与具体实现无关。可以理解为中间代码是一种非常抽象，又非常普适的代码。它客观中立的描述了代码要做的事情，如果用中文、英文来分别表示  C 和 Java 的话，中间码某种意义上可以被理解为世界语。</p>
<p>另一方面，中间代码是编译器前端和后端的分界线。编译器前端负责把源码转换成中间代码，编译器后端负责把中间代码转换成汇编代码。</p>
<p>LLVM IR 是一种中间代码，它长成这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define i32 @square_unsigned(i32 %a) &#123;</div><div class="line">  %1 = mul i32 %a, %a</div><div class="line">  ret i32 %1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="生成目标代码"><a href="#生成目标代码" class="headerlink" title="生成目标代码"></a>生成目标代码</h2><p>目标代码也可以叫做汇编代码。由于中间代码已经非常接近于实际的汇编代码，它几乎可以直接被转化。主要的工作量在于兼容各种 CPU 以及填写模板。在最终生成的汇编代码中，不仅有汇编命令，也有一些对文件的说明。比如:</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    .file       <span class="string">"test.c"</span>      # 文件名称</div><div class="line">    <span class="meta">.global</span>     m             # 全局变量 m</div><div class="line">    <span class="meta">.data</span>                     # 数据段声明</div><div class="line">    <span class="meta">.align</span>      <span class="number">4</span>             # <span class="number">4</span> 字节对齐</div><div class="line">    .type       m, <span class="comment">@objc</span></div><div class="line">    .size       m, <span class="number">4</span></div><div class="line">m:</div><div class="line">    <span class="meta">.long</span>       <span class="number">10</span>            # m 的值是 <span class="number">10</span></div><div class="line">    <span class="meta">.text</span></div><div class="line">    <span class="meta">.global</span>     main</div><div class="line">    .type       main, <span class="comment">@function</span></div><div class="line"><span class="symbol">main</span>:</div><div class="line">    <span class="keyword">pushl </span>  %ebp</div><div class="line">    <span class="keyword">movl </span>   %esp,   %ebp</div><div class="line">    ...</div></pre></td></tr></table></figure>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编器会接收汇编代码，将它转换成二进制的机器码，生成目标文件(后缀是 .o)，机器码可以直接被 CPU 识别并执行。从目标代码可以猜出来，最终的目标文件(机器码)也是分段的，这主要有以下三个原因:</p>
<ol>
<li>分段可以将数据和代码区分开。其中代码只读，数据可写，方便权限管理，避免指令被改写，提高安全性。</li>
<li>现代 CPU  一般有自己的数据缓存和指令缓存，区分存储有助于提高缓存命中率。</li>
<li>当多个进程同时运行时，他们的指令可以被共享，这样能节省内存。</li>
</ol>
<p>段分离我们并不遥远，比如命令行中的 <code>objcopy</code> 可以自行添加自定义的段名，C 语言的 <code>__attribute((section(段名)))__</code> 可以把变量定义在某个特定名称的段中。</p>
<p>对于一个目标文件来说，文件的最开头(也叫作 ELF 头)记录了目标文件的基本信息，程序入口地址，以及段表的位置，相当于是对文件的整体描述。接下来的重点是段表，它记录了每个段的段名，长度，偏移量。比较常用的段有:</p>
<ul>
<li>.strtab 段: 字符串长度不定，分开存放浪费空间(因为需要内存对齐)，因此可以统一放到字符串表(也就是 .strtab 段)中进行管理。字符串之间用 <code>\0</code> 分割，所以凡是引用字符串的地方用一个数字就可以代表。</li>
<li>.symtab: 表示符号表。符号表统一管理所有符号，比如变量名，函数名。符号表可以理解为一个表格，每行都有符号名(数字)、符号类型和符号值(存储地址)</li>
<li>.rel 段: 它表示一系列重定位表。这个表主要在链接时用到，下面会详细解释。</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>在一个目标文件中，不可能所有变量和函数都定义在文件内部。比如 <code>strlen</code> 函数就是一个被调用的外部函数，此时就需要把 <code>main.o</code> 这个目标文件和包含了 <code>strlen</code> 函数实现的目标文件链接起来。我们知道函数调用对应到汇编其实是 <code>jump</code> 指令，后面写上被调用函数的地址，但在生成 <code>main.o</code> 的过程中，<code>strlen()</code> 函数的地址并不知道，所以只能先用 0 来代替，直到最后链接时，才会修改成真实的地址。</p>
<p>链接器就是靠着重定位表来知道哪些地方需要被重定位的。每个可能存在重定位的段都会有对应的重定位表。在链接阶段，链接器会根据重定位表中，需要重定位的内容，去别的目标文件中找到地址并进行重定位。</p>
<p>有时候我们还会听到动态链接这个名词，它表示重定位发生在运行时而非编译后。动态链接可以节省内存，但也会带来加载的性能问题，这里不详细解释，感兴趣的读者可以阅读《程序员的自我修养》这本书。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>最后简单描述一下预处理。预处理主要是处理一些宏定义，比如 <code>#define</code>、<code>#include</code>、<code>#if</code> 等。预处理的实现有很多种，有的编译器会在词法分析前先进行预处理，替换掉所有 # 开头的宏，而有的编译器则是在词法分析的过程中进行预处理。当分析到 # 开头的单词时才进行替换。虽然先预处理再词法分析比较符合直觉，但在实际使用中，GCC 使用的却是一边词法分析，一边预处理的方案。</p>
<h1 id="编译-VS-解释"><a href="#编译-VS-解释" class="headerlink" title="编译 VS 解释"></a>编译 VS 解释</h1><p>总结一下，对于 C 语言来说，从源码到运行结果大致上需要经历编译、汇编和链接三个步骤。编译器接收源代码，输出目标代码(也就是汇编代码)，汇编器接收汇编代码，输出由机器码组成的目标文件(二进制格式，.o 后缀)，最后链接器将各个目标文件链接起来，执行重定位，最终生成可执行文件。</p>
<p>编译器以中间代码为界限，又可以分前端和后端。比如 clang 就是一个前端工具，而 LLVM 则负责后端处理。另一个知名工具 GCC(GNU Compile Collection)则是一个套装，包揽了前后端的所有任务。前端主要负责预处理、词法分析、语法分析，最终生成语言无关的中间代码。后端主要负责目标代码的生成和优化。</p>
<p>关于编译原理的基础知识虽然枯燥，但掌握这些知识有助于我们理解一些有用的，但不太容易理解的概念。接下来，我们简单看一下别的语言是如何运行的。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>在 Java 代码的执行过程中，可以简单分为编译和执行两步。Java 的编译器首先会把 .java 格式的源码编译成 .class 格式的字节码。字节码对应到 C 语言的编译体系中就是中间码，Java 虚拟机执行这些中间码得到最终结果。</p>
<p>回忆一下上文对中间码的解释，一方面它与语言无关，仅仅描述客观事实。另一方面它和目标代码的差距并不大，已经包括了对寄存器和栈的处理，仅仅是抽象了 CPU 架构而已，只要把它具体化成各个平台下的目标代码，就可以交给汇编器了。</p>
<h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><p>一般来说我们也把解释型语言叫做脚本语言，比如 Python、Ruby、JavaScript 等等。这类语言的特点是，不需要编译，直接由解释器执行。换言之，运行流程变成了:</p>
<blockquote>
<p>源代码 -&gt; 解释器 -&gt; 运行结果</p>
</blockquote>
<p>需要注意的是，这里的解释器只是一个黑盒，它的实现方式可以是多种多样的。举个例子，它的实现可以非常类似于 Java 的执行过程。解释器里面可以包含一个编译器和虚拟机，编译器把源码转化成 AST 或者字节码(中间代码)然后交给虚拟机执行，比如 Ruby 1.9 以后版本的官方实现就是这个思路。</p>
<p>至于虚拟机，它并不是什么黑科技，它的内部可以编译执行，也可以解释执行。如果是编译执行，那么它会把字节码编译成当前 CPU 下的机器码然后统一执行。如果是解释执行，它会逐条翻译字节码。</p>
<p>有意思的是，如果虚拟机是编译执行的，那么这套流程和 C 语言几乎一样，都满足下面这个流程:</p>
<blockquote>
<p>源代码 -&gt; 中间代码 -&gt; 目标代码 -&gt; 运行结果</p>
</blockquote>
<p><strong>下面是重点!!!</strong><br><strong>下面是重点!!!</strong><br><strong>下面是重点!!!</strong></p>
<p>因此，解释型语言和编译型语言的根本区别在于，对于用户来说，到底是直接从源码开始执行，还是从中间代码开始执行。以 C 语言为例，所有的可执行程序都是二进制文件。而对于传统意义的 Python 或者 JavaScript，用户并没有拿到中间代码，他们直接从源码开始执行。从这个角度来看， Java 不可能是解释型语言，虽然 Java 虚拟机会解释字节码，但是对于用户来说，他们是从编译好的 .class 文件开始执行，而非源代码。</p>
<p>实际上，在 x86 这种复杂架构下，二进制的机器码也不能被硬件直接执行，CPU 会把它翻译成更底层的指令。从这个角度来说，我们眼中的硬件其实也是一个虚拟机，执行了一些“抽象”指令，但我相信不会有人认为 C 语言是解释型语言。因此，有没有虚拟机，虚拟机是不是解释执行，会不会生成中间代码，这些都不重要，重要的是如果从中间代码开始执行，而且 AST 已经事先生成好，那就是编译型的语言。</p>
<p>如果更本质一点看问题，<strong>根本就不存在解释型语言或者编译型语言这种说法</strong>。已经有人证明，如果一门语言是可以解释的，必然可以开发出这门语言的编译器。反过来说，如果一门语言是可编译的，我只要把它的编译器放到解释器里，把编译推迟到运行时，这么语言就可以是解释型的。事实上，早有人开发出了 C 语言的解释器:</p>
<blockquote>
<p>C  源代码 -&gt; C 语言解释器(运行时编译、汇编、链接) -&gt; 运行结果</p>
</blockquote>
<p>我相信这一点很容易理解，规范和实现是两套分离的体系。我们平常说的 C 语言的语法，实际上是一套规范。理论上来说每个人都可以写出自己的编译器来实现 C 语言，只要你的编译器能够正确运行，最终的输出结果正确即可。而编译型和解释型说的其实是语言的实现方案，是提前编译以获得最大的性能提高，还是运行时去解析以获得灵活性，往往取决于语言的应用场景。所以说一门语言是编译型还是解释型的，这会非常可笑。一个标准怎么可能会有固定的实现呢？之所以给大家留下了 C 语言是编译型语言，Python 是解释型语言的印象，往往是因为这门语言的应用场景决定了它是主流实现是编译型还是解释型。</p>
<h1 id="自举"><a href="#自举" class="headerlink" title="自举"></a>自举</h1><p>不知道有没有人思考过，C 语言的编译器是如何实现的？实际上<strong>它还是用 C 语言实现的</strong>。这种自己能编译自己的神奇能力被称为自举(Bootstrap)。</p>
<p>乍一看，自举是不可能的。因为 C 语言编译器，比如 GCC，要想运行起来，必定需要 GCC 的编译器将它编译成二进制的机器码。然而 GCC 的编译器又如何编译呢……</p>
<p>解决问题的关键在于打破这个循环，我们可以先用一个比 C 语言低级的语言来实现一个 C 语言编译器。这件事是可能做到的，因为这个低级语言必然会比 C 语言简单，比如我们可以直接用汇编代码来写 C 语言的编译器。由于越低级的语言越简单，但表达能力越弱，所以用汇编来写可能太复杂。这种情况下我们可以先用一个比 C 语言低级但比汇编高级的语言来实现 C 语言的编译器，同时用汇编来实现这门语言的编译器。总之就是不断用低级语言来写高级语言的编译器，虽然语言越低级，它的表达能力越弱，但是它要解析的语言也在不断变简单，所以这件事是可以做到的。</p>
<p>有了低级语言写好的  C 语言编译器以后，这个编译器是二进制格式的。此时就可以删掉所有的低级语言，只留一个二进制格式的 C 语言编译器，接下来我们就可以用 C 语言写编译器，再用这个二进制格式的编译器去编译 C 语言实现的 C 语言编译器了，于是完成了自举。</p>
<p>以上逻辑描述起来比较绕，但我想多读几遍应该可以理解。如果实在不理解也没关系，我们只要明白 C 语言可以自举是因为它可以编译成二进制机器码，只要用低级语言生成这个机器码，就不再需要低级语言了，因为机器码可以直接被 CPU 执行。</p>
<p>从这个角度来看，解释型语言是不可能自举的。以 Python 为例，自举要求它能用 Python 语言写出来 Python 的解释器，然而这个解释器如何运行呢，最终还是需要一个解释器。而解释器体系下， Python 都是从源码经过解释器执行，又不能留下什么可以直接被硬件执行的二进制形式的解释器文件，自然是没办法自举的。然而，就像前面说的，Python 完全可以实现一个编译器，这种情况下它就是可以自举的。</p>
<p>所以一门语言能不能自举，主要取决于它的实现形式能否被编译并留下二进制格式的可执行文件。</p>
<h1 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h1><p>本文的读者如果是使用 Objective-C 的 iOS 开发者，想必都有过在面试时被 runtime 支配的恐惧。然而，runtime 并非是 Objective-C 的专利，绝大多数语言都有这个概念。所以有人说 Objective-C 具有动态性是因为它有 runtime，这种说法并不准确，我觉得要把 Objective-C 的 runtime 和一般意义的运行时库区分开，认识到它仅仅是运行时库的一个组成部分，同时还是要深入到方法调用的层面来谈。</p>
<h2 id="运行时库的基本概念"><a href="#运行时库的基本概念" class="headerlink" title="运行时库的基本概念"></a>运行时库的基本概念</h2><p>以 C 语言为例，有非常多的操作最终都依赖于 <strong>glibc</strong> 这个动态链接库。包括但不限于字符串处理(<code>strlen</code>、<code>strcpy</code>)、信号处理、socket、线程、IO、动态内存分配(malloc)等等。这一点很好理解，如果回忆一下之前编译器的工作原理，我们会发现它仅仅是处理了语言的语法，比如变量定义，函数声明和调用等等。至于语言的功能， 比如内存管理，內建的类型，一些必要功能的实现等等。如果要对运行时库进行分类，大概有两类。一种是语言自身功能的实现，比如一些內建类型，内置的函数；另一种则是语言无关的基础功能，比如文件 IO，socket 等等。</p>
<p>由于每个程序都依赖于运行时库，这些库一般都是动态链接的，比如 C 语言的 (g)libc。这样一来，运行时库可以存储在操作系统中，节省内存占用空间和应用程序大小。</p>
<p>对于 Java 语言来说，它的垃圾回收功能，文件 IO 等都是在虚拟机中实现，并提供给 Java 层调用。从这个角度来看，虚拟机/解释器也可以被看做语言的运行时环境(库)。</p>
<h2 id="swift-运行时库"><a href="#swift-运行时库" class="headerlink" title="swift 运行时库"></a>swift 运行时库</h2><p>经过这样的解释，相信 swift 的运行时库就很容易理解了。一方面，swift 是绝对的静态语言，另一方面，swift 毫无疑问的带有自己的运行时库。举个最简单的例子，如果阅读 swift 源码就会发现某些类型，比如字符串(String)，或者数组，再或者某些函数(print)都是用 swift 实现的，这些都是 swift 运行时库的一部分。按理说，运行时库应该内置于操作系统中并且和应用程序动态链接，然而坑爹的 Swift 在本文写作之时依然没有稳定 ABI，导致每个程序都必须自带运行时库，这也就是为什么目前 swift 开发的 app 普遍会增加几 Mb 包大小的原因。</p>
<p>说到 ABI，它其实就是一个编译后的 API。简单来说，API 是描述了在应用程序级别，模块之间的调用约定。比如某个模块想要调用另一个模块的功能，就必须根据被调用模块提供的 API 来调用，因为 API 中规定了方法名、参数和返回结果的类型。而当源码被编译成二进制文件后，它们之间的调用也存在一些规则和约定。</p>
<p>比如模块 A 有两个整数 a 和 b，它们的内存布局如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">模块 A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始地址</td>
</tr>
<tr>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">b</td>
</tr>
</tbody>
</table>
<p>这时候别的模块调用 A 模块的 b 变量，可以通过初始地址加偏移量的方式进行。</p>
<p>如果后来模块 A 新增了一个整数 c，它的内存布局可能会变成:</p>
<table>
<thead>
<tr>
<th style="text-align:center">模块 A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始地址</td>
</tr>
<tr>
<td style="text-align:center">c</td>
</tr>
<tr>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">b</td>
</tr>
</tbody>
</table>
<p>如果调用方还是使用相同的偏移量，可以想见，这次拿到的就是变量 a 了。因此，每当模块 A 有更新，所有依赖于模块 A 的模块都必须重新编译才能正确工作。如果这里的模块 A 是 swift 的运行时库，它内置于操作系统并与其他模块(应用程序)动态链接会怎么样呢？结果就是每次更新系统后，所有的 app 都无法打开。显然这是无法接受的。</p>
<p>当然，ABI 稳定还包括其他的一些要求，比如调用和被调用者遵守相同的调用约定(参数和返回值如何传递)等。</p>
<h1 id="JavaScript-那些事"><a href="#JavaScript-那些事" class="headerlink" title="JavaScript 那些事"></a>JavaScript 那些事</h1><p>我们继续刚才有关运行时的话题，先从 JavaScript 的运行时聊起，再介绍 JavaScript 的相关知识。</p>
<h2 id="JavaScript-是如何运行的"><a href="#JavaScript-是如何运行的" class="headerlink" title="JavaScript 是如何运行的"></a>JavaScript 是如何运行的</h2><p>JavaScript 和其他语言，无论是 C 语言，还是 Python 这样的脚本语言，最大的区别在于 JavaScript 的宿主环境比较奇怪，一般来说是浏览器。</p>
<p>无论是 C 还是 Python，他们都有一个编译器/解释器运行在操作系统上，直接把源码转换成机器码。而 JavaScript 的解释器一般内置在浏览器中，比如 Chrome 就有一个 V8 引擎可以解析并执行 JavaScript 代码。因此 JavaScript 的能力实际上会受到宿主环境的影响，有一些限制和加强。</p>
<p>首先来看看 DOM 操作，相关的 API 并没有定义在 ECMAScript 标准中，因此我们常用的 <code>window.xxx</code> 还有 <code>window.document.xxx</code> 并非是 JavaScript 自带的功能，这通常是由宿主平台通过 C/C++ 等语言实现，然后提供给 JavaScript 的接口。同样的，由于浏览器中的 JavaScript 只是一个轻量的语言，没有必要读写操作系统的文件，因此浏览器引擎一般不会向 JavaScript 提供文件读写的运行时组件，它也就不具备 IO 的能力。从这个角度来看，整个浏览器都可以看做 JavaScript 的虚拟机或者运行时环境。</p>
<p>因此，当我们换一个宿主环境，比如 Node.js，JavaScript 的能力就会发生变化。它不再具有 DOM API，但多了读写文件等能力。这时候，Node.js 就更像是一个标准的 JavaScript 解析器了。这也是为什么 Node.js 让 JavaScript 可以编写后端应用的原因。</p>
<h2 id="JIT-优化"><a href="#JIT-优化" class="headerlink" title="JIT 优化"></a>JIT 优化</h2><p>解释执行效率低的主要原因之一在于，相同的语句被反复解释，因此优化的思路是动态的观察哪些代码是经常被调用的。对于那些被高频率调用的代码，可以用编译器把它编译成机器码并且缓存下来，下次执行的时候就不用重新解释，从而提升速度。这就是 JIT(Just-In-Time) 的技术原理。</p>
<p>但凡基于缓存的优化，一定会涉及到缓存命中率的问题。在 JavaScript 中，即使是同一段代码，在不同上下文中生成的机器码也不一定相同。比如这个函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这里的 a 和 b 都是整数，可以想见最终的代码一定是汇编中的 <code>add</code> 命令。如果类似的加法运算调用了很多次，解释器可能会认为它值得被优化，于是编译了这段代码。但如果下一次调用的是 <code>add(&quot;hello&quot;, &quot;world&quot;)</code>，之前的优化就无效了，因为字符串加法的实现和整数加法的实现完全不同。</p>
<p>于是优化后的代码(二进制格式)还得被还原成原先的形式(字符串格式)，这样的过程被称为去优化。反复的优化 -&gt; 去优化 -&gt; 优化 …… 非常耗时，大大降低了引入 JIT 带来的性能提升。</p>
<p>JIT 理论上给传统的 JavaScript 带了了 20-40 倍的性能提升，但由于上述去优化的存在，在实际运行的过程中远远达不到这个理论上的性能天花板。</p>
<h2 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h2><p>前文说过，JavaScript 实际上是由浏览器引擎负责解析并提供一些功能的。浏览器引擎可能是由 C++ 这样高效的语言实现的，那么为什么不用 C++  来写网页呢？实际上我认为从技术角度来说并不存在问题，直接下发 C++ 代码，然后交给 C++ 解释器去执行，再调用浏览器的 C++ 组件，似乎更加符合直觉一些。</p>
<p>之所以选择 JavaScript 而不是 C++，除了主流浏览器目前都只支持 JavaScript 而不支持 C++ 这个历史原因以外，更重要的一点是一门语言的高性能和简单性不可兼得。JavaScript 在运行速度方面做出了牺牲，但也具备了简单易开发的优点。作为通用编程语言，JavaScript 和 C++ 主要的性能差距就在于缺少类型标注，导致无法进行有效的提前编译。之前说过 JIT 这种基于缓存去猜测类型的方式存在瓶颈，那么最精确的方式肯定还是直接加上类型标注，这样就可以直接编译了，代表性的作品有 Mozilla 的 <a href="http://asmjs.org/" target="_blank" rel="external">Asm.js</a>。</p>
<p>Asm.js 是 JavaScript 的一个子集，任何 JavaScript 解释器都可以解释它:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    a = a | <span class="number">0</span>  <span class="comment">// 任何整数和自己做按位或运算的结果都是自己</span></div><div class="line">    b = b | <span class="number">0</span>  <span class="comment">// 所以这个标记不改变运算结果，但是可以提示编译器 a、b 都是整数</span></div><div class="line">    <span class="keyword">return</span> a + b | <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有 Asm.js 特定的解释器，完全可以把它提前编译出来。即使没有也没关系，因为它完全是 JavaScript 语法的子集，普通的解释器也可以解释。</p>
<p>然而，回顾一下我们最初对解释器的定义: 解释器是一个黑盒，输入源码，输出运行结果。Asm.js 其实是黑盒内部的一个优化，不同的黑盒(浏览器)无法共享这一优化。换句话说 Asm.js 写成的代码放到 Chrome  上面和普通的 JavaScript 毫无区别。</p>
<p>于是，包括微软、谷歌和苹果在内的各大公司觉得，是时候搞个标准了，这个标准就是 WebAssembly 格式。它是介于中间代码和目标代码之间的一种二进制格式，借用 <a href="https://zhuanlan.zhihu.com/p/25754084" target="_blank" rel="external">WebAssembly 系列（四）WebAssembly 工作原理</a> 一文的插图来表示:</p>
<p><img src="https://pic1.zhimg.com/v2-282dc5b30b62517ed56a187d43a6ab90_b.png" alt=""></p>
<p>通常从中间代码到机器码，需要经过平台具体化(转目标代码)和二进制化(汇编器把汇编代码变为二进制机器码)这两个步骤。而 WebAssembly 首先完成了第二个步骤，即已经是二进制格式的，但只是一系列虚拟的通用指令，还需要转换到各个 CPU 架构上。这样一来，从 WebAssembly 到机器码其实是透明且统一的，各个浏览器厂商只需要考虑如何从中间代码转换 WebAssembly 就行了。</p>
<p>由于编译器的前端工具 Clang 可以把 C/C++ 转换成中间代码，因此理论上它们都可以用来开发网页。然而谁会这么这么做呢，放着简单快捷，现在又高效的 JavaScript 不写，非要去啃 C++？</p>
<h1 id="跨语言那些事儿"><a href="#跨语言那些事儿" class="headerlink" title="跨语言那些事儿"></a>跨语言那些事儿</h1><p>C++ 写网页这个脑洞虽然比较大，但它启发我思考一个问题:“对于一个常见的可以由某个语言完成的任务(比如 JavaScript 写网页)，能不能换一个语言来实现(比如 C++)，如果不能，制约因素在哪里”。</p>
<p>由于绝大多数主流语言都是<a href="http://mp.weixin.qq.com/s/0Dp63Lx3eSzG06Z8YonX6g" target="_blank" rel="external">图灵完备的</a>，也就是说一切可计算的问题，在这些语言层面都是等价的，都可以计算。那么制约语言能力的因素也就只剩下了运行时的环境是否提供了相应的功能。比如前文解释过的，虽然浏览器中的 JavaScript 不能读写文件，不能实现一个服务器，但这是浏览器(即运行时环境)不行，不是 JavaScript 不行，只要把运行环境换成 Node.js 就行了。</p>
<h2 id="直接语法转换"><a href="#直接语法转换" class="headerlink" title="直接语法转换"></a>直接语法转换</h2><p>大部分读者应该接触过简单的逆向工程。比如编译后的 .o 目标文件和 .class 字节码都可以反编译成源代码，这种从中间代码倒推回源代码的技术也被叫做反编译(decompile)，反编译器的工作流程基本上是编译器的倒序，只不过完美的反编译一般来说比较困难，这取决于中间代码的实现。像 Java 字节码这样的中间代码，由于信息比较全，所以反编译就相对容易、准确一些。C 代码在生成中间代码时丢失了很多信息，因此就几乎不可能 100% 准确的倒推回去，感兴趣的读者可以参考一下知名的反编译工具 <a href="https://www.hex-rays.com/products/ida/support/ppt/decompilers_and_beyond_white_paper.pdf" target="_blank" rel="external">Hex-Rays 的一篇博客</a>。</p>
<p>前文说过，编译器前端可以对多种语言进行词法分析和语法分析，并且生成一套语言无关的中间代码，因此理论上来说，如果某个编译器前端工具支持两个语言 A 和 B 的解析，那么 A 和 B 是可以互相转换的，流程如下:</p>
<blockquote>
<p>A 源码 &lt;–&gt; 语言无关的中间代码 &lt;–&gt; B 源码</p>
</blockquote>
<p>其中从源码转换到中间代码需要使用编译器，从中间代码转换到源码则使用反编译器。</p>
<p>但在实际情况中，事情会略复杂一些，这是因为中间代码虽然是一套语言无关、CPU 也无关的指令集，但不代表不同语言生成的中间代码就可以通用。比如中间代码共有 1、2、3、……、6 这六个指令。A 语言生成的中间代码仅仅是所有指令的一个子集，比如是 1-5 这 5 个指令；B 语言生成的中间代码可能是所有指令的另一个子集，比如 2-6。这时候我们说的 B 语言的反编译器，实际上是从 2-6 的指令子集推导出 B 语言源码，它对指令 1 可能无能为力。</p>
<p>以 GCC 的中间代码 <a href="https://zh.wikipedia.org/wiki/%E6%9A%AB%E5%AD%98%E5%99%A8%E5%82%B3%E9%81%9E%E8%AA%9E%E8%A8%80" target="_blank" rel="external">RTL: Register Transfer Language</a> 为例，<a href="https://gcc.gnu.org/onlinedocs/gccint/GENERIC.html#GENERIC" target="_blank" rel="external">官方文档</a> 在对 RTL 的解释中，就明确的把 RTL 树分为了通用的、C/C++ 特有的、Java 特有的等几个部分。</p>
<p><img src="http://images.bestswifter.com/1498235065.png" alt=""></p>
<p>具体来说，我们知道 Java 并不能直接访问内存地址，这一点和浏览器上的 JavaScript 不能读写文件很类似，都是因为它们的运行环境(虚拟机)具备这种能力，但没有在语言层面提供。因此，含有指针四则运算的 C 代码无法直接被转换成 Java 代码，因为 Java 字节码层面并没有定义这样的抽象，一种简单的方案是申请一个超大的数组，然后自己模拟内存地址。</p>
<p>所以，即使编译器前端同时支持两种语言的解析，要想进行转换，还必须处理两种语言在中间代码层面的一些小差异，实际流程应该是:</p>
<blockquote>
<p>A 源码 &lt;–&gt; 中间代码子集(A) &lt;–适配器–&gt; 中间代码子集(B) &lt;–&gt; B 源码</p>
</blockquote>
<p>这个思路已经不仅仅停留在理论上了，比如 Github 上有一个库: <a href="https://github.com/kripken/emscripten" target="_blank" rel="external">emscripten</a> 就实现了将任何 Clang 支持的语言(比如 C/C++ 等)转换成 JavaScript，再比如 <a href="https://github.com/davidar/lljvm" target="_blank" rel="external">lljvm</a> 实现了 C 到 Java 字节码的转换。</p>
<p>然而前文已经解释过，实现单纯语法的转换意义并不大。一方面，对于图灵完备的语言来说，换一种表示方法(语言)去解决相同的问题并没有意义。另一方面，语言的真正功能绝不仅仅是语法本身，而在于它的运行时环境提供了什么样的功能。比如 Objective-C 的 Foundation 库提供了字典类型 <code>NSDictionary</code>，它如果直接转换成 C 语言，将是一个找不到的符号。因为 C 语言的运行时环境根本就不提供对这种数据结构的支持。因此凡是在语言层面进行强制转换的，要么利用反编译器拿到一堆格式正确但无法运行的代码，要么就自行解析语法树并为转换后的语言添加对应的能力，来实现转换前语言的功能。</p>
<p><img src="http://images.bestswifter.com/1497887162.png" alt=""></p>
<p>比如图中就是一个 C 语言转换 Java 的工具，为了实现 C 语言中的字符串申请和释放内存，这个工具不得不自己实现了 <code>com.mtsystems.coot.String8</code> 类。这样巨大的成本，显然不够普适，应用场景相对有限。</p>
<p>总之，直接的语法转换是一个美好的想法，但实现起来难度大，收益有限，通常是为了移植已经用某个语言写好的框架，或者开个脑洞用于学习，但实际应用场景并不多。</p>
<h2 id="胶水语言-Python"><a href="#胶水语言-Python" class="headerlink" title="胶水语言 Python"></a>胶水语言 Python</h2><p>Python 一个很强大的特点是胶水语言，可以把 Python 理解为各种语言的粘合剂。对于 Python 可以处理的逻辑，用 Python 代码即可完成。如果追求极致的性能或者调用已经实现的功能，也可以让 Python 调用已经由别的语言实现的模块，以 Python 和 C 语言的交互解释一下。</p>
<p>首先，如果是 C 语言要执行 Python 代码，显然需要一个 Python 的解释器。由于在 Mac OS X 系统上，Python 解释器是一个动态链接库，所以只要导入一下头文件即可，下面这段代码可以成功输出 “Hello Python!!!”:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Python/Python.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    Py_SetProgramName(argv[<span class="number">0</span>]);</div><div class="line">    Py_Initialize();</div><div class="line">    PyRun_SimpleString(<span class="string">"print 'Hello Python!!!'\n"</span>);</div><div class="line">    Py_Finalize();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是在 iOS 应用里，由于 iOS 系统没有对应的动态库，所以需要把 Python 的解释器打包成一个静态库并且链接到应用中，网上已经有人做好了: <a href="https://github.com/cobbal/python-for-iphone" target="_blank" rel="external">python-for-iphone</a>，这就是为什么我们看到一些<a href="http://pythonforios.com/" target="_blank" rel="external">教育类的应用</a>模拟了 Python 解释器，允许用户编写 Python 代码并得到输出。</p>
<p>Python 调用 Objective-C/C 也不复杂，只需要在 C 代码中指定要暴露的模块 A  和要暴露的方法 a，然后 Python 就可以直接调用了:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> A</div><div class="line">A.a()</div></pre></td></tr></table></figure>
<p>详细的教程可以看这里: <a href="https://www.zhihu.com/question/23003213" target="_blank" rel="external">如何实现 C/C++ 与 Python 的通信？</a></p>
<p>有时候，如果能把自己熟悉的语言应用到一个陌生的领域，无疑会大大降低上手的难度。以 iOS 开发为例，开发者的日常其实是利用 Objective-C 语法来描述一些逻辑，最终利用 UIKit 等框架完成和应用的交互。 一种很自然而然的想法是，能不能用 Python 来实现逻辑，并且调用 Objective-C 的接口，比如 UIKit、Foundation 等。实际上前者是完全可以实现的，但是 Python 调用 Objective-C 远比调用 C 语言要复杂得多。</p>
<p>一方面从之前的分析中也能看出，并不是所有的源码编译成目标文件都可以被 Python 引用；另一方面，最重要的是 Objective-C 方法调用的特性。我们知道方法调用实际上会被编译成 <code>msg_Send</code> 并交给 runtime 处理，最终找到函数指针并调用。这里 Objective-C 的 runtime 其实是一个用 C 语言实现动态链接库，它可以理解为 Objective-C 运行时环境的一部分。换句话说，没有 runtime 这个库，包含方法调用的 Objective-C 代码是不可能运行起来的，因为 <code>msg_Send</code> 这个符号无法被重定向，运行时将找不到 <code>msg_Send</code> 函数的地址。就连原生的 Objective-C 代码都需要依赖运行时，想让 Python 直接调用某个 Objective-C 编译出来的库就更不可能了。</p>
<p>想用 Python 写开发 iOS 应用是有可能的，比如: <a href="https://pythonhosted.org/pyobjc/" target="_blank" rel="external">PyObjc</a>，但最终还是要依赖 Runtime。大概的思路是首先用 Python 拿到 runtime 这个库，然后通过这个库去和 runtime 交互，进而具备了调用 Objective-C 和各种框架的能力。比如我要实现 Python 中的 <code>UIView</code> 这个类，代码会变成这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> objc</div><div class="line"></div><div class="line"><span class="comment"># 这个 objc 是动态加载 libobjc.dylib 得到的</span></div><div class="line"><span class="comment"># Python 会对 objc 做一些封装，提供调用 runtime 的能力</span></div><div class="line"><span class="comment"># 实际的工作还是交给 libobjc.dylib 完成</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIView</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, param)</span>:</span></div><div class="line">		objc.msgSend(<span class="string">"UIView"</span>, <span class="string">"init"</span>, param)</div></pre></td></tr></table></figure>
<p>这么做的性价比并不高，如果和 JSPatch 相比，JSPatch 使用了内置的 JavaScriptCore 作为 JavaScript 的解析器，而 PyObjc 就得自己带一个 libPython.a 解释器。此外，由于 iOS 系统的沙盒限制，非越狱机器并不能拿到 libobjc 库，所以这个工具只能在越狱手机上使用。</p>
<h2 id="OCS"><a href="#OCS" class="headerlink" title="OCS"></a>OCS</h2><p>既然说到了 JSPatch 这一类动态化的 iOS 开发工具，我就斗胆猜测一下腾讯 OCS 的实现原理，目前介绍 OCS 的文章寥寥无几，由于苹果公司的要求，原文已经被删除，从新浪博客上摘录了一份: <a href="http://blog.sina.com.cn/s/blog_1328b55460102xayq.html" target="_blank" rel="external">OCS ——史上最疯狂的 iOS 动态化方案</a>。如果用一句话来概述，那么就是 OCS 是一个 Objective-C 解释器。</p>
<p>首先，OCS 基于 clang 对下发的 Objective-C 代码做词法、语法分析，生成 AST 然后转化成自定义的一套中间码(OSScript)。当然，原生的 Objective-C 可以运行，绝不仅仅是编译器的功劳。就像之前反复强调的那样，运行时环境也必不可少，比如负责 GCD 的 libdispatch 库，还有内存管理，多线程等等功能。这些功能原来都由系统的动态库实现，但现在必须由解释器实现，所以 OCS 的做法是开发了一套自己的虚拟机去解释执行中间码。这个运行原理就和 JVM 非常类似了。</p>
<p>当然，最终还是要和 Objective-C 的 Runtime 打交道，这样才能调用 UIKit 等框架。由于对虚拟机的实现原理并不清楚，这里就不敢多讲了，希望在学习完 JVM 以后再做分享。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://blog.csdn.net/wusuopubupt/article/details/26378845" target="_blank" rel="external">AT&amp;T与Intel汇编风格比较</a></li>
<li><a href="http://baike.baidu.com/link?url=KLKsJxx7NgDSulEVqwpy0SW_w5sCGDVev9LamscTl-4mHPuKNb5O-kQh44XZpzTkXbC--iQOodC2IDWeW0Z_i_" target="_blank" rel="external">glibc</a></li>
<li><a href="http://huziketang.com/blog/posts/detail?postId=58ce8036a6d8a07e449fdd27" target="_blank" rel="external">WebAssembly 系列（一）生动形象地介绍 WebAssembly</a></li>
<li><a href="https://www.hex-rays.com/products/ida/support/ppt/decompilers_and_beyond_white_paper.pdf" target="_blank" rel="external">Decompilers and beyond</a></li>
<li><a href="https://github.com/cobbal/python-for-iphone" target="_blank" rel="external">python-for-iphone</a></li>
<li><a href="https://www.zhihu.com/question/23003213" target="_blank" rel="external">如何实现 C/C++ 与 Python 的通信？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25754084" target="_blank" rel="external">WebAssembly 系列（四）WebAssembly 工作原理</a></li>
<li><a href="http://www.jianshu.com/p/9083823b8318" target="_blank" rel="external">扯淡：大白话聊聊编译那点事儿</a></li>
<li><a href="https://github.com/pybee/rubicon-objc" target="_blank" rel="external">rubicon-objc</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_1328b55460102xayq.html" target="_blank" rel="external">OCS ——史上最疯狂的 iOS 动态化方案</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/492667" target="_blank" rel="external">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</a></li>
<li><a href="https://zhihu.com/question/49176184/answer/116708101" target="_blank" rel="external">JavaScript的功能是不是都是靠C或者C++这种编译语言提供的？</a></li>
<li><a href="https://www.zhihu.com/question/25017764/answer/142836802" target="_blank" rel="external">计算机编程语言必须能够自举吗?</a></li>
<li><a href="https://zhihu.com/question/31415286/answer/58022648" target="_blank" rel="external">如何评论浏览器最新的 WebAssembly 字节码技术？</a></li>
<li><a href="https://niyaoyao.github.io/2016/07/29/Objective-C-Runtime-From-Build-To-Did-Launch/" target="_blank" rel="external">Objective-C Runtime —— From Build To Did Launch</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gccint/GENERIC.html#GENERIC" target="_blank" rel="external">10 GENERIC</a></li>
<li><a href="https://www.zhihu.com/question/51380338" target="_blank" rel="external">写个编译器，把C++代码编译到JVM的字节码可不可行？</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我刚刚进入大学，从零开始学习 C 语言的时候，我就不断的从学长的口中听到一个又一个语言，比如 C++、Java、Python、JavaScript 这些大众的，也有 Lisp、Perl、Ruby 这些相对小众的。一般来说，当程序员讨论一门语言的时候，默认的上下文经常是:“
    
    </summary>
    
    
      <category term="编程语言" scheme="http://fullstack.blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>指针和引用的区别</title>
    <link href="http://fullstack.blog/2017/06/16/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://fullstack.blog/2017/06/16/指针和引用的区别/</id>
    <published>2017-06-15T16:50:05.000Z</published>
    <updated>2017-06-15T16:58:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>从概念理解和用法上来讲，C/C++ 中的指针和 Java 等语言中的引用非常类似。它们和被指向的内容分开存储(一般存储在栈上)，并且持有被指向的对象的地址。通过指针/引用，我们可以方便的操作实际的对象。</p>
<p>当然，区别还是有的。C 系的指针更加透明，换句话说指针其实就是一个整数，只不过这个整数恰好表示了被指向的变量的地址。这是一种非常简单的，直来直去的表示方法。而 Java 等语言的引用就像是一个黑盒了。Java 的规范并没有要求引用的值一定就是内存地址，在实现的时候，它有可能有一个中间层进行映射，但最终还是指针的模型，也就是说依然会持有地址，只不过从使用者的角度来看，地址的概念经过封装已经不存在了。具体的做法我不太清楚，据说是为了提高垃圾回收算法的效率。</p>
<h1 id="指针可以进行四则运算"><a href="#指针可以进行四则运算" class="headerlink" title="指针可以进行四则运算"></a>指针可以进行四则运算</h1><p>一个是透明的数字，表示内存地址。一个是不透明的中间层，带来的直接区别就是指针可以进行四则运算。指针四则运算在提供方便的同时，也相当危险，比如这段代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">4</span>] = &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</div><div class="line">    <span class="keyword">int</span> array2[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, array2[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个十二次的 for 循环中，前八次的输出结果毫无疑问是依次输出 <code>array2</code> 数组的每个元素。但之后的四次循环并不会发送数组越界，而是相当“正常的”输出了 <code>array</code> 数组的元素。在大部分机器上，这段代码的运行结果应该是依次输出 1 到 12 这 12 个数字。</p>
<p>实际上，这里的输出结果完全是由 <code>array</code> 和 <code>array2</code> 两个数组变量在内存中的布局决定的，如果增加或减少一点 <code>array</code> 数组的长度，恐怕就没有那么幸运了。</p>
<p>可见，透明的指针带来的问题在于，开发者知道了太多他们本来不该知道的东西(比如开发者竟然可以拿到变量的真实地址，还可以不借助变量名就访问一个变量，比如这里的 <code>array</code>)。在某些精心构造的场合下，攻击者甚至可以通过修改字符串的值来控制程序的执行逻辑，只要计算得当，他们可以调用原本根本不会被调用的函数。</p>
<p>在引用的概念中，引用就是引用，它什么也不是，更不可能是数字，也就谈不上什么四则运算了。因此想要通过 A 对象的引用来访问 B 对象是完全不可能的。</p>
<h1 id="指针无法检查类型"><a href="#指针无法检查类型" class="headerlink" title="指针无法检查类型"></a>指针无法检查类型</h1><p>指针的灵活性除了体现在四则运算外，还包括它对类型的弱检查。实际上，因为指针仅仅是数字，它根本没有检查类型的可能。C 的 <code>reinterpret_cast</code> 方法可以将任何一个类型的指针转化为其它任何一个类型的指针，这种做法可以通过编译，但会在运行时报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> value = <span class="number">21</span>; </div><div class="line">Person p = <span class="keyword">reinterpret_cast</span>&lt;Person&gt; (&amp;value);</div></pre></td></tr></table></figure>
<p>比如我们可以把一个整数的指针转换成对象类型，然后到处拿去使用，最终将会得到一个 <code>EXC_BAD_ACCESS</code> 的错误。</p>
<p>绝大多数时候，<code>reinterpret_cast</code> 既危险，也鸡肋。倒是在计算对象的哈希值时，把指针类型转换成整数类型会有助于计算:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">Hash</span><span class="params">( <span class="keyword">void</span> *p )</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;( p );</div><div class="line">    <span class="keyword">return</span> ( <span class="keyword">unsigned</span> <span class="keyword">short</span> )( val ^ (val &gt;&gt; <span class="number">16</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而引用由于具备了中间层，完全可以在编译期进行类型检查，确保被转换的类型之间存在继承关系，从而确保安全性:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Father father = <span class="keyword">new</span> Son(); <span class="comment">// 正常</span></div><div class="line"></div><div class="line">Father father = <span class="keyword">new</span>  Father();</div><div class="line">Son son = (Son) father;  <span class="comment">// ClassCastException</span></div></pre></td></tr></table></figure>
<p>至于在运行时进行类型检测，这已经是另一码事了。单就编译期而言，引用对类型的控制能力远超过指针。</p>
<h1 id="引用是未来的趋势"><a href="#引用是未来的趋势" class="headerlink" title="引用是未来的趋势"></a>引用是未来的趋势</h1><p>很多人通过分析 Swift 的优点来解释为什么 Swift 会取代 Objective-C。他们说的都对，因为这些确实是 Swift 的优点；但说的也都错，因为这些都不是取代 Objective-C 的理由。</p>
<p>因为 Swift 的创造者自己已经解释过了，OC 是基于 C 语言的，使用的是指针的模型，这就注定了 OC 不是一门安全的语言。而 Swift 采用了引用的模型，仅通过 <code>UnsafePointer</code> 开放了微弱的指针能力，它的命名也时刻提醒使用者，指针的操作是不安全的。</p>
<p>而那些所谓的  Swift 的优点，没有一个是替换 Objective-C 的理由，因为它们要么可以在 Objective-C 上引入，要么并不见得优于 Objective-C。</p>
<p>如果站在架构或者工程的角度来看问题的话，框架的提供者应该为使用者提供尽可能简洁的操作，一方面降低使用成本，最重要的则是减少出错概率。可能出现的错误往往会随着可以使用的操作的线性增加而几何式的增加。如何提供一些简单的，正交的基础操作，让使用者在有限、可控的操作下完成全部任务，是设计的艺术，也是对设计者的挑战。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从概念理解和用法上来讲，C/C++ 中的指针和 Java 等语言中的引用非常类似。它们和被指向的内容分开存储(一般存储在栈上)，并且持有被指向的对象的地址。通过指针/引用，我们可以方便的操作实际的对象。&lt;/p&gt;
&lt;p&gt;当然，区别还是有的。C 系的指针更加透明，换句话说指针其
    
    </summary>
    
    
      <category term="编程语言" scheme="http://fullstack.blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的工厂模式</title>
    <link href="http://fullstack.blog/2017/04/19/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fullstack.blog/2017/04/19/我眼中的工厂模式/</id>
    <published>2017-04-19T07:12:54.000Z</published>
    <updated>2017-04-19T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>仅是一家之言，欢迎交流讨论、指正错误。</p>
</blockquote>
<p>本科有一门课程是设计模式，上课的时候读完了《Head First 设计模式》，这是一本很好的书，可惜当时的我不是一个好读者，囫囵吞枣看了几百页却没有吸收精华。工作以后，有了一些代码量的积累，打算补一补设计模式相关的内容。</p>
<p>这篇文章讲工厂模式，在开始分析之前，我想谈谈我对设计模式的看法。以前我之所以学不好设计模式，一方面是自己代码量不足，只能纸上谈兵，另一方面我想也和介绍设计模式的文章有关。大多数文章重点在于介绍 xxx 模式是什么，然后配上千篇一律的类图(Class Diagram) 和 Demo。好一点的文章，类图和 Demo 容易理解点，有可能还会谈谈某两个模式之间的异同。</p>
<p>但设计模式是什么？是一门必须掌握的课程，一些必须背下来的概念，然后放到实际工程里面套用的么？我不敢苟同，在我看来涉及模式其实描述了一些 Coding 的技巧。所谓的技巧，有的是能够节省冗余代码，更重要的则是开闭原则，也就是“<strong>对拓展开放，对修改关闭</strong>”，或者说得再直白点，就是方便开发者后期维护的。</p>
<p>这些技巧是有限的、反复出现的，为了便于交流和沟通，我们给这些技巧起上名字，否则每个人对这些技巧都有自己的理解，就不方便沟通了。既然是技巧，那么一定有它<strong>“巧”</strong>的一面，对比的则是原来不巧的代码。所以理解某个设计模式的实现是次要的，重点是理解它巧在哪里，因为要理解巧在哪里，所以顺便要看看如何实现。</p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>上面这些话可能有点虚、有点绕，没关系，我举个具体例子来说。这篇文章介绍的是工厂模式，工厂模式根据“教科书”，分为三种:</p>
<ol>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ol>
<p>既然是工厂，那么肯定是用来生产东西的，所以有的教材或者书籍把它归类于“创建型模式”，我是坚决反对的。还有很多文章，动不动就是工厂、材料的举例，如果你以为只有创建东西，还需要材料时才用得着工厂模式，那么设计模式这门学问基本上就算失败了。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>以那个经典的披萨的例子来说吧，父类叫 <code>Pizza</code>，子类有很多，什么 <code>GoodPizza</code>、<code>BadPizza</code>、<code>LargePizza</code>、<code>SmallPizza</code> 之类的随便写。</p>
<p>问题来了，这么多可能的披萨，怎么选择呢？当然是用参数来标记了。比如订披萨的时候:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Snippet 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">    Pizza pizza = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span>(type.equals(<span class="string">"g"</span>))&#123;</div><div class="line">        pizza = <span class="keyword">new</span> GoodPizza();</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"b"</span>))&#123;</div><div class="line">        pizza = <span class="keyword">new</span> BadPizza();</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"l"</span>))&#123;</div><div class="line">        pizza = <span class="keyword">new</span> LargePizza();</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        pizza = <span class="keyword">new</span> SmallPizza();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pizza;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>第一段代码是原始场景，它只是实现了需求，我给它起个名字叫学校代码(School Code)，也就是那些学校里的学生写出来的，仅仅是可以运行的代码。问题很明显，一方面你不能保证只有在订披萨的时候才会创建披萨的实例对象，如果别的地方也要创建披萨对象，相同的代码就要重写一遍。另一方面这样写会导致 <code>orderPizza</code> 所在的类依赖于 <code>Pizza</code> 的四个子类，而实际上的需求仅仅是创建披萨实例而已，它的调用者并不应该依赖于具体的子类。</p>
<p>因此在订披萨的地方处理这样的字符串判断就显得不合理，解决方案也很简单，用一个专门的类来处理创建披萨的逻辑就行了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Snippet 2</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        Pizza pizza = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"g"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> GoodPizza();</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"b"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> BadPizza();</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"l"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> LargePizza();</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            pizza = <span class="keyword">new</span> SmallPizza();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">    SimplePizzaFactory simplePizzaFactory = <span class="keyword">new</span> SimplePizzaFactory();</div><div class="line">    Pizza pizza= simplePizzaFactory.createPizza(type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是简单工厂方法了，它说的是两个概念:</p>
<ol>
<li>一个类只做和自己相关的事，不依赖的别瞎依赖</li>
<li>有可能复用的代码抽出去，独立成类，不要到处重复</li>
</ol>
<p>这个模式和什么所谓的 <strong>工厂</strong> 一点关系都没有。假如这里调用的不是 <code>new</code> 关键字来新建对象，而是用类的静态方法，一样会有依赖问题。这种大段的细节逻辑，不管是不是创建对象，还是可以被独立出去。</p>
<p>采用了简单工厂模式以后，n 个披萨需要 n+1 个类，额外的那个是工厂类，处理创建披萨对象的具体逻辑。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>我们考虑一下新增披萨种类的情况。在第二段代码的实现中，如果要新增一个子类，需要在 <code>SimplePizzaFactory</code> 中新增对子类的依赖和解析方法，也就是多一个 <code>else if</code> 的分支。如果是删除一种披萨，就需要删掉一个子类的依赖和 <code>else if</code> 分支。</p>
<p>这个操作看起来并不复杂，虽然要增改代码，但还是可以接受。不过如果子类无法修改 <code>SimplePizzaFactory</code> 代码呢？父类和工厂类有可能是基础团队在维护，而披萨子类可能是业务团队维护，不同的业务团队还有可能维护不同的子类。且不说不一定有代码的写权限，就算大家一起写，代码冲突了怎么办，忘记删除逻辑了怎么办？</p>
<p>这时候就看出问题所在了，它违反了开闭原则，也就是说并没有做到对修改关闭。怎么对修改关闭呢，这就需要借助 OOP 编程时的一个小技巧。</p>
<p>直接上代码吧，为了偷懒，我直接把 <a href="https://segmentfault.com/p/1210000009074890/read" target="_blank" rel="external">深入浅出工厂设计模式</a> 这篇文章的里的代码搬过来改改了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//snippet 3</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">APizzaStore</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        Pizza pizza= createPizza(type);</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodPizzaStore</span> <span class="keyword">extends</span> <span class="title">APizzaStore</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        Pizza pizza = <span class="keyword">new</span> GoodPizza();</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用工厂方法模式以后，工厂不再负责具体的业务细节。它变成了一个抽象类，规定了一个<strong>抽象方法</strong> <code>createPizza</code> <strong>强迫</strong> 子类实现。同时它在 <code>orderPizza</code> 函数中调用了这个方法，但方法的实现者并不是自己。因为实际使用的并不是抽象工厂类 <code>APizzaStore</code> 而是具体的 <code>GoodPizzaStore</code>，利用<strong>多态性</strong>，实际调用的也是子类的 <code>createPizza</code> 方法。</p>
<p>所以归根结底，抽象工厂方法只是使用了一个小技巧，我称之为:</p>
<blockquote>
<p>父类定框架，子类做填充，依赖多态性</p>
</blockquote>
<p>这种技巧的好处在于将具体实现下降到各个子类中实现，父类仅仅指定这些方法何时被调用，从而不再关心有多少子类，实现了“对拓展开放、对修改关闭”。当然你也会发现方法的调用者不能再偷懒，传递字符串就能拿到合适的披萨类型了，现在</p>
<p>当然，使用工厂方法模式也有代价，对于 n 个披萨类型，现在我们需要 2n+1 个类了。其中 n 个 <code>Pizza</code> 的子类，1 个 <code>APizzaStore</code> 的抽象类负责制定流程框架，n 个 <code>APizzaStore</code> 的子类负责实现细节。</p>
<p>以还是那句话，工厂方法模式和 <strong>工厂</strong> 半毛钱关系都没有。它只是一种 OOP 下的编程技巧，在任何场景下都有可能使用。但这个技巧和语言有点关系，比如这里的例子是 Java 语言。我们知道 Java 可以把一个类标记为 <code>abstract</code>，虚拟类有一个虚拟方法。子类如果想变成具体类就必须实现这个虚拟方法。但是在 OC 中并没有虚拟类的概念，父类的空方法子类完全可以不实现，那么就无法在编译时作出这些规定，只能靠文档和 Code Review 来督促(父类方法抛错是运行时)。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>最后聊聊抽象工厂模式，依我愚见，抽象工厂模式和 <strong>工厂</strong> 更没关系。</p>
<p>在某些极端情况下，披萨的种类可能会特别多，但并不是毫无规律的多。可能会出现可以归类的情况。比如我们考虑两个维度，一个是披萨的产地，可以是中国、美国、印度、日本等等，另一个是披萨的口味，它的数量有限，只有麻辣、微辣和不辣三种:</p>
<p><img src="http://images.bestswifter.com/1492518813.png" alt=""></p>
<p>这里画了个很简单图表，一共有 15 种披萨。我们可以用中国不辣、日本不辣、印度不辣来描述三种披萨，也可以先建立三个披萨工场，分别用来生产不辣、微辣、麻辣的披萨，然后用不辣工厂的中国披萨、日本披萨、印度披萨来描述上述三种披萨。这有点类似于数学里面提取公因数的概念。</p>
<p>假设我们建立了三个工厂，分别生产不辣、微辣、麻辣的披萨，以微辣工厂为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//snippet 4</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">APizzaFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ChinesePizza <span class="title">createChinesePizza</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JapanesePizza <span class="title">createJapanesePizza</span><span class="params">()</span></span>;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AmericanPizza <span class="title">createAmericanPizza</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HotFactory</span> <span class="keyword">extends</span> <span class="title">APizzaFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ChinesePizza <span class="title">createChinesePizza</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HotChinesePizza();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JapanesePizza <span class="title">createJapanesePizza</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HotJapanesePizza();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AmericanPizza <span class="title">createAmericanPizza</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HotAmericanPizza();  </div><div class="line">    &#125;</div><div class="line">&#125;  </div><div class="line"></div><div class="line">HotFactory hotFactory = <span class="keyword">new</span> HotFactory();  </div><div class="line">ChinesePizza pizza = hotFactory.createChinesePizza();</div></pre></td></tr></table></figure>
<p>这样我们在创建披萨的时候就不用了解 15 个具体子类了，只要了解三种工厂和五个种类。换句话说我们把一个很长的一维数组(1 x 15)转化了二维数组，每个维度的长度都不大(3 x 5)。我们还可以换一个思路，比如建立五个工厂，分别表示不同国家，然后每个工厂可以生产三种不同口味的披萨。</p>
<p>那么到底是以口味为标准建立工厂，还是以国家为标准呢？我的建议是尽量减少新增工厂的可能性。比如上图中可以看到，新增口味的成本是添加五个国家披萨在这个新口味下的实现，而新增国家的成本仅仅是在已有的三个工厂中各增加一个方法。可见新增工厂(口味)比新增产品(国家)更麻烦一些。所以在上述例子中，个人建议针对不同的口味建立工厂，在实际项目中作出正确的选择应该也不会太困难。</p>
<p>考虑到披萨子类过多，而且大部分可以分类，在实际项目中为了节省代码量，我们还可以用反射的方式来动态获取类并生成实例。</p>
<p>总之，抽象工厂模式名字很玄乎，但是概念也很简单，就是用二维数组的思想来简化数量多、但可以分类的数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是学习设计模式的第一篇文章，从比较简单的工厂方法开始讲起。重点是忽略设计模式的表象，挖掘背后的原理。比如工厂模式就和工厂、创建对象没啥关系:</p>
<ol>
<li>简单工厂模式: 具体逻辑由具体类处理，减少不必要依赖，方便代码复用</li>
<li>工厂方法模式: 父类定框架，子类做实现，利用多态的特点实现对拓展开放，对修改关闭</li>
<li>抽象工厂模式: 借用二维数组的概念对复杂的子类做分类，简化业务逻辑。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>本文写作过程中参考了以下两篇文章，但他们并不权威:</p>
<ol>
<li><a href="https://segmentfault.com/p/1210000009074890/read" target="_blank" rel="external">深入浅出工厂设计模式</a></li>
<li><a href="http://lh-kevin.iteye.com/blog/1981574" target="_blank" rel="external">简单工厂、工厂方法、抽象工厂、策略模式、策略与工厂的区别</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;仅是一家之言，欢迎交流讨论、指正错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本科有一门课程是设计模式，上课的时候读完了《Head First 设计模式》，这是一本很好的书，可惜当时的我不是一个好读者，囫囵吞枣看了几百页却没有吸收精华。工作以后
    
    </summary>
    
    
      <category term="zen" scheme="http://fullstack.blog/tags/zen/"/>
    
  </entry>
  
  <entry>
    <title>试图取代 TCP 的 QUIC 协议到底是什么</title>
    <link href="http://fullstack.blog/2017/04/03/%E8%AF%95%E5%9B%BE%E5%8F%96%E4%BB%A3%20TCP%20%E7%9A%84%20QUIC%20%E5%8D%8F%E8%AE%AE%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://fullstack.blog/2017/04/03/试图取代 TCP 的 QUIC 协议到底是什么/</id>
    <published>2017-04-03T01:28:34.000Z</published>
    <updated>2017-04-24T01:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>QUIC 协议是 Google 提出的一套开源协议，它基于 UDP 来实现，直接竞争对手是 TCP 协议。QUIC 协议的性能非常好，甚至在某些场景下可以实现 0-RTT 的加密通信。所以这篇文章主要讨论以下几个问题:</p>
<ol>
<li>QUIC 协议有哪些优点，如何实现 0-RTT</li>
<li>传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点</li>
<li>为什么 Google 要另起炉灶，基于 UDP 去做</li>
</ol>
<p>这三个问题并不独立，所以我不会依次解答他们，我选择从一些常识入手，逐渐深入到底层细节。希望读者能够带着问题阅读并最终获得满意的答案。</p>
<h1 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h1><p>网络请求中一个常见的名词是 RTT(Round Trip Time)，表示客户端从发出一个请求数据，到接收到响应数据之间间隔的时间。</p>
<p><img src="http://images.bestswifter.com/RTT.png" alt="RTT"></p>
<p>RTT 可以理解成由两部分组成，一部分受到物理条件的限制，比如间隔距离除以信号传递速度，以及包大小除以带宽。另一部分则是客户端、服务器以及沿途各路由器对包的处理解析时间。一般情况下，RTT 大约在几十毫秒左右，网络很好的情况下可以达到个位数，恶劣网络环境下达到几百毫秒也有可能。</p>
<p>根据阮一峰的 <a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="external">SSL延迟有多大？</a> 一文中做的计算，用户访问支付宝时，一个 RTT 大约需要 22ms，算上 SSL 握手的三个 RTT 则大约消耗了 64ms。</p>
<p>可见网络请求时间绝对不是简单的数据量除以网速这么简单， RTT 是网络请求耗时中不可忽略的一部分，不仅仅是握手阶段需要三个 RTT，在实际网络请求中，还有可能因为丢包等问题而额外增加 RTT。因此任何一个能减少 RTT 的技术都值得认真考虑，因为他们<strong>真的能够显著降低</strong>网络请求耗时。</p>
<h2 id="QUIC-协议概述"><a href="#QUIC-协议概述" class="headerlink" title="QUIC 协议概述"></a>QUIC 协议概述</h2><p>下面进入正题，本文的主角，QUIC 协议主要具备以下优点:</p>
<ol>
<li>多路复用，避免队头阻塞</li>
<li>减少 RTT，请求更快速</li>
<li>快速迭代，广泛支持</li>
</ol>
<h1 id="多路复用，避免队头阻塞"><a href="#多路复用，避免队头阻塞" class="headerlink" title="多路复用，避免队头阻塞"></a>多路复用，避免队头阻塞</h1><p>这句话说起来很容易，但理解起来并不那么显然，要想理解 QUIC 协议到底做了什么以及这么做的必要性，我想还是从最基础的 HTTP 1.0 聊起比较合适。</p>
<h2 id="Pipiline"><a href="#Pipiline" class="headerlink" title="Pipiline"></a>Pipiline</h2><p>根据谷歌的调查， 现在请求一个网页，平均涉及到 80 个资源，30 多个域名。考虑最原始的情况，每请求一个资源都需要建立一次 TCP 请求，显然不可接受。HTTP 协议规定了一个字段 <code>Connection</code>，不过默认的值是 <code>close</code>，也就是不开启。</p>
<p>早在 1999 年提出的 <a href="https://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">HTTP 1.1 协议</a> 中就把 <code>Connection</code> 的默认值改成了<code>Keep-Alive</code>，这样同一个域名下的多个 HTTP 请求就可以复用同一个 TCP 连接。这种做法被称为 HTTP Pipeline，优点是显著的减少了建立连接的次数，也就是大幅度减少了 RTT。以上面的数据为例，如果 80 个资源都要走一次 HTTP 1.0，那么需要建立 80 个 TCP 连接，握手 80 次，也就是 80 个 RTT。如果采用了 HTTP 1.1 的 Pipeline，只需要建立 30 个 TCP 连接，也就是 30 个 RTT，提高了 <strong>62.5%</strong> 的效率。</p>
<p>Pipeline 解决了 TCP 连接浪费的问题，但它自己还存在一些不足之处，也就是所有管道模型都难以避免的队头阻塞问题。</p>
<h2 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h2><p>我们再举个简单而且直观的例子，假设加载一个 HTML 一共要请求 10 个资源，那么请求的总时间是每一个资源请求时间的总和。最直观的体验就是，网速越快请求时间越短。然而如果某一个资源的请求被阻塞了(比如 SQL 语句执行非常慢)。但对于客户端来说所有后续的请求都会因此而被阻塞。</p>
<p><img src="http://images.bestswifter.com/HOC.png" alt="HOC"></p>
<p>队头阻塞(Head of line blocking，下文简称 HOC)说的是当有多个串行请求执行时，如果第一个请求不执行完，后续的请求也无法执行。比如上图中，如果第四个资源的传输花了很久，后面的资源都得等着，平白浪费了很多时间，带宽资源没有得到充分利用。</p>
<p>因此，HTTP 协议允许客户端发起多个并行请求，比如在笔者的机器上最多支持六个并发请求。并发请求主要是用于解决 HOC 问题，当有三个并发请求时，情况会变成这样:</p>
<p><img src="http://images.bestswifter.com/Multi.png" alt="Multi Request"></p>
<p>可见虽然第四个资源的请求被阻塞了，但是其他的资源请求并不一定会被阻塞，这样总的来说网络的平均利用率得到了提升。</p>
<p>支持并发请求是解决解决 HOC 问题的一种方案，这句话没有错，但是我们要理解到: “并发请求并非是直接解决了 HOC 的问题，而是尽可能减少 HOC 造成的影响”，以上图为例，HOC 的问题依然存在，只是不会太浪费带宽而已。有读者可能会好奇，为什么不多搞几个并发的 HTTP 请求呢？刚刚说过笔者的电脑最多支持 6 个并发请求，谷歌曾经做过实验，把 6 改成 10，然后尝试访问了三千多个网页，发现平均访问时间竟然还增加了 5% 左右。这是因为一次请求涉及的域名有限，再多的并发 HTTP 请求并不能显著提高带宽利用率，反而会消耗性能。</p>
<h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>有没有办法解决队头阻塞呢，答案是肯定的。SPDY 协议的做法很值得借鉴，它采用了多路复用(Multiplexing) 技术，允许多个 HTTP 请求共享同一个 TCP 连接。我们假设每个资源被分为多个包传递，在 HTTP 1.1 中只有前面一个资源的所有数据包传输完毕后后面资源的包才能开始传递(HOC 问题)，而 SPDY 并不这么要求，大家可以一起传输。</p>
<p><img src="http://images.bestswifter.com/1491491570.png" alt=""></p>
<p>这么做的代价是数据会略微有一些冗余，每一个资源的数据包都要带上标记，用来指明自己属于哪个资源，这样客户端最后才能把他们正确的拼接起来。不同的标记可以理解为图中不同的颜色，每一个小方格可以理解为资源的某一个包。</p>
<p>有些读者对 SPDY 协议可能不太了解，其实把它当做 HTTP2 的前身和试验品就好。当然 HTTP2.0 的好处远远不止这些，比如我们可以很容易的基于 HTTP2.0 实现长连接，而以往的选择要么是用更底层的 TCP，要么是使用与 HTTP 同级的 Web Socket 协议。现在 HTTP 协议直接支持了长连接，对开发者而言确实是一大利好。考虑到本篇文章主要是讨论 QUIC 协议相关，就不对 HTTP 2.0 做详细分析了。</p>
<h2 id="茶歇小结"><a href="#茶歇小结" class="headerlink" title="茶歇小结"></a>茶歇小结</h2><p>刚刚聊到了三个技术名词，Pipeline、并发请求和多路复用，千万不要被绕晕了。</p>
<p>Pipeline 是为了减少不必要的 TCP 连接，但依然存在队头阻塞(HOC)的缺点，一种解决思路是利用并发连接减少某一个 HOC 的影响，另一个是共享(<strong>注意与复用的区别</strong>) TCP 连接，直接避免 HOC 问题的发生。</p>
<h2 id="TCP-窗口"><a href="#TCP-窗口" class="headerlink" title="TCP 窗口"></a>TCP 窗口</h2><p>是不是觉得 SPDY 的多路复用已经够厉害了，解决了队头阻塞问题？很遗憾的是，并没有，而且我可以很肯定的说，只要你还在用 TCP 链接，HOC 就是逃不掉的噩梦，不信我们来看看 TCP 的实现细节。</p>
<p>我们知道 TCP 协议会保证数据的可达性，如果发生了丢包或者错包，数据就会被重传。于是问题来了，如果一个包丢了，那么后面的包就得停下来等这个包重新传输，也就是发生了队头阻塞。当然 TCP 协议的设计者们也不傻，他们发明了滑动窗口的概念:</p>
<p><img src="http://images.bestswifter.com/network/tcp-window.png" alt="TCP 窗口"></p>
<p>这样的好处是在第一个数据包(1-1000) 发出后，不必等到 ACK 返回就可以立刻发送第二个数据包。可以看出图中的 TCP 窗口大小是 4，所以第四个包发送后就会开始等待，直到第一个包的 ACK 返回。这样窗口可以向后滑动一位，第五个包被发送。</p>
<p>如果第一、二、三个的包都丢失了也没有关系，当发送方收到第四个包时，它可以确信一定是前三个 ACK 丢了而不是数据包丢了，否则不会收到 4001 的 ACK，所以发送方可以大胆的把窗口向后滑动四位。</p>
<p>滑动窗口的概念大幅度提高了 TCP 传输数据时抗干扰的能力，一般丢失一两个 ACK 根本没关系。但如果是发送的包丢失，或者出错，窗口就无法向前滑动，出现了队头阻塞的现象。</p>
<h2 id="QUIC-多路复用与纠错"><a href="#QUIC-多路复用与纠错" class="headerlink" title="QUIC 多路复用与纠错"></a>QUIC 多路复用与纠错</h2><p>所以说 HOC 不仅仅在 HTTP 层存在，在 TCP 层也存在，这也正是 QUIC 协议要解决的问题。回顾 SPDY 是如何解决 HOC 的，没错，多路复用(Multiplex)。QUIC 协议也采用了多路复用技术。</p>
<p><img src="http://images.bestswifter.com/1491206971.png" alt="QUIC 多路复用"></p>
<p>QUIC 协议基于 UDP 实现，我们知道 UDP 协议只负责发送数据，并不保证数据可达性。这一方面为 QUIC  的多路复用提供了基础，另一方面也要求 QUIC 协议自己保证数据可达性。</p>
<p>SPDY 为各个数据包做好标记，指明他们属于哪个 HTTP 请求，至于这些包能不能到达客户端，SPDY 并不关心，因为数据可达性由 TCP 协议保证。既然客户端一定能收到包，那就只要排序、拼接就行了。QUIC 协议采用了多路复用度思想，但同时还得自己保证数据的可达性。</p>
<p>TCP 协议的丢包重传并不是一个好想法，因为一旦有了前后顺序，队头阻塞问题将不可避免。而无序的数据发送给接受者以后，如何保证不丢包，不错包呢？这看起来是个不可能完成的任务，不过如果把要求降低成:“最多丢一个包，或者错一个包”，事情就简单多了，操作系统中有一种存储方式叫 RAID 5，采用的是异或运算加上数据冗余的方式来保证前向纠错(FEC: Forward Error Correcting)。</p>
<p>我们知道异或运算的规则是，<code>0 ^ 1 = 1</code>、<code>1 ^ 1 = 0</code>，也就是相同数字异或成 1，不同数字异或成 0。对两个数字做异或运算，其实就是将他们转成二进制后按位做异或，因此对于任何数字 a，都有:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a ^ a = <span class="number">0</span></div><div class="line">a ^ <span class="number">0</span> = a</div></pre></td></tr></table></figure>
<p>同时很容易证明异或运算满足交换律和结合律，我们假设有下面这个等式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A1 ^ A2 ^ A3 ^ ... ^ An = T</div></pre></td></tr></table></figure>
<p>如果想让等式的左边只留下一个一个元素，只要在等号两边做 n-1 次异或就可以了:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(A1 ^ A1) ^ A2 ^ A3 ^ ... ^ An = T ^ A1</div><div class="line"><span class="comment">// 所以</span></div><div class="line">A2 ^ A3 ^ ... ^ An = T ^ A1</div><div class="line"><span class="comment">// 所以</span></div><div class="line">A3 ^ ... ^ An = T ^ A1 ^ A2</div><div class="line"><span class="comment">// 所以 ......</span></div><div class="line">Ai = T ^ A1 ^ A2 ^ ... Ai<span class="number">-1</span> ^ Ai+<span class="number">1</span> ^ Ai+<span class="number">2</span> ^ ... ^ An</div></pre></td></tr></table></figure>
<p>换句话说，A1 到 An 和 T 这总共 n+1 个元素中，不管是任何一个元素缺失，都可以从另外 n 个元素推导出来。如果把 A1、A2 一直到 An 想象成要发送的数据，T 想象成冗余数据，那么除了丢包重传，我们还可以采用冗余数据包的形式来保证数据准确性。</p>
<p>举个例子，假设有 5 个数据包要发送，我可以额外发送一个包(上面例子中的 T)，它的值是前五个包的异或结果。这样不管是前五个包中丢失了任何一个，或者某个包数据有错(可以当成丢包来处理)，都可以用另外四个包和这个冗余的包 T 进行异或运算，从而恢复出来。</p>
<p>当然要注意的是，这种方案仅仅在只发生一个错包或丢包时有效，如果丢失两个包就无能为力了(这也就是为什么只发一个冗余包就够的原因)。因此数据包和冗余包之间的比值需要精心设计，如果比值过高，很容易出现丢两个包的情况，如果比值过低，又会导致冗余度太高，需要设计者根据概率计算结果进行权衡。</p>
<p>利用冗余数据的思想，QUIC 协议基本上避免了重发数据的情况，这种利用已有数据就能进行错误恢复的技术叫做前向恢复(FEC: Fowrard Error Correcting)。当然 QUIC 协议还是支持重传的，比如某些非常重要的数据或者丢失两个包的情况。</p>
<h1 id="更少的-RTT"><a href="#更少的-RTT" class="headerlink" title="更少的 RTT"></a>更少的 RTT</h1><p>我们考虑一次 HTTPS 请求，它的基本流程是三次 TCP 握手外加四次 SSL/TLS 握手，从图中可以看到这需要三个 RTT:</p>
<p><img src="http://images.bestswifter.com/3-RTT.png" alt="3 RTT"></p>
<p>对于 HTTP 2.0 来说，本来需要一个额外的 RTT 来进行协商，判断客户端与服务器是不是都支持 HTTP 2.0，不过好在它可以和 SSL 握手的请求合并。这也就是为什么大多数主流浏览器(比如 Chrome、Firefox) 仅支持 HTTPS 2.0 而不单独支持 HTTP 2.0 的原因，毕竟 HTTP 2.0 需要一个额外的 RTT，HTTPS 2.0 需要两个额外的 RTT，仅仅是增加一个 RTT 就能获得数据安全性，还是很划算的。</p>
<h2 id="SSL-握手优化"><a href="#SSL-握手优化" class="headerlink" title="SSL 握手优化"></a>SSL 握手优化</h2><p>有关 HTTPS 的详细解释可以参考我之前的文章: <a href="http://www.jianshu.com/p/072a657337ae" target="_blank" rel="external">九个问题从入门到熟悉HTTPS</a>，这里我们简单复习一下 SSL 握手的大致流程:</p>
<ol>
<li>客户端发送第一个握手，包含一个随机数，以及对协议的支持情况(版本、加密方法、压缩方法等)</li>
<li>服务器返回证书，以及服务端生成随机数</li>
<li>客户端校验证书，生成一个新的随机数，用证书中的公钥加密后发给服务端</li>
<li>服务端确认消息，双方根据上述三个随机数生成后续会话的公钥</li>
</ol>
<p>由于需要确认证书，生成多个随机数来保证安全，握手阶段的两个 RTT 很难节省。不过之前我们见过 HTTP 的 Pipeline 技术可以复用 TCP 连接，那么按照类似的思想，SSL 连接也可以被恢复。思考一下为什么 SSL 要设计这么复杂的握手机制，它本质上是为了保证对称秘钥的安全传输，所以 SSL 会话恢复主要考虑的也是如何恢复对称秘钥。</p>
<p>一个常用的方案是采用 Session Ticket，实现起来很容易: 一旦 SSL 会话建立起来，服务端把会话的基本信息，比如对称秘钥、加密方法等信息加密后发给客户端，客户端可以缓存下来这个 Session Ticket。需要恢复 SSL 会话时直接把它发回给服务端校验即可，这样可以在 SSL 层减少一个 RTT。</p>
<h2 id="TCP-快速打开"><a href="#TCP-快速打开" class="headerlink" title="TCP 快速打开"></a>TCP 快速打开</h2><p>聊完了 SSL 层，下面说说 TCP 的优化方案。我们都知道 TCP 的三次握手需要花费一个 RTT，有没有可能做到 0-RTT 呢？比如我们在握手的时候就带上要传递的数据。</p>
<p>实际上 TCP 协议已经规定了这种情况的处理方式，即客户端可以在发送第一个 SYN 握手包时携带数据，但是 TCP 协议的实现者<strong>绝对不允许</strong>(原文: MUST NOT) 把这个数据包上传给应用层。这主要是为了防止 TCP 泛洪攻击。</p>
<p>TCP 泛洪攻击是指攻击者利用多台机器发送 SYN 请求从而耗尽服务器的 backlog 队列，backlog 队列维护的是那些接受了 SYN 请求但还没有正式开始会话的连接。这样做的好处是服务器不会过早的分配端口、建立连接。<a href="https://tools.ietf.org/html/rfc4987" target="_blank" rel="external">RFC 4987</a> 详细的描述了各种防止 TCP 泛洪攻击的方法，包括尽早释放 SYN，增加队列长度等等。</p>
<p>如果 SYN 握手的包能被传输到应用层，那么现有的防护措施都无法防御泛洪攻击，而且服务端也会因为这些攻击而耗尽内存和 CPU。所以人们设计了 TFO (TCP Fast Open)，这是对 TCP 的拓展，不仅可以在发送 SYN 时携带数据，还可以保证安全性。</p>
<p>TFO 设计了一个 cookie，它在第一次握手时由 server 生成，cookie 主要是用来标识客户端的身份，以及保存上次会话的配置信息。因此在后续重新建立 TCP 连接时，客户端会携带 SYN + Cookie + 请求数据，然后不等 ACK 返回就直接开始发送数据。</p>
<p><img src="http://images.bestswifter.com/1491536313.png" alt="TFO 工作示意图"></p>
<p>服务端收到 SYN 后会验证 cookie 是否有效，如果无效则会退回到三次握手的步骤，如下图所示:</p>
<p><img src="http://images.bestswifter.com/1491536652.png" alt="回退到普通三次握手"></p>
<p>同时，为了安全起见，服务端为每个端口记录了一个值 <code>PendingFastOpenRequests</code>，用来表示有多少请求利用了 TFO，如果超过预设上限就不再接受。</p>
<p>关于 TFO 的优化，可以总结出三点内容:</p>
<ol>
<li>TFO 设计的 cookie 思想和 SSL 恢复握手时的 Session Ticket 很像，都是由服务端生成一段 cookie 交给客户端保存，从而避免后续的握手，有利于快速恢复。</li>
<li>第一次请求绝对不会触发 TFO，因为服务器会在接收到 SYN 请求后把 cookie 和 ACK 一起返回。后续客户端如果要重新连接，才有可能使用这个 cookie 进行 TFO</li>
<li>TFO 并不考虑在 TCP 层过滤重复请求，以前也有类似的提案想要做过滤，但因为无法保证安全性而被拒绝。所以 TFO 仅仅是避免了泛洪攻击(类似于 backlog)，但客户端接收到的，和 SYN 包一起发来的数据，依然有可能重复。不过也只有可能是 SYN 数据重复，所以 TFO 并不处理这种情况，要求服务端程序自行解决。这也就是说，不仅仅要操作系统的支持，更要求应用程序(比如 MySQL) 也支持 TFO。</li>
</ol>
<h2 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h2><p>TFO 使得 TCP 协议有可能变成 0-RTT，核心思想和 Session Ticket 的概念类似: 将当前会话的上下文缓存在客户端。如果以后需要恢复对话，只需要将缓存发给服务器校验，而不必花费一个 RTT 去等待。</p>
<p>结合 TFO 和 Session Ticket 技术，一个本来需要花费 3 个 RTT 才能完成的请求可以被优化到一个 RTT。如果使用 QUIC 协议，我们甚至可以更进一步，将 Session Ticket 也放到 TFO 中一起发送，这样就实现了 0-RTT 的对话恢复。感兴趣的读者可以阅读: <a href="https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113095&amp;idx=1&amp;sn=0f7beafe5f48b4fdcde5465373044eab" target="_blank" rel="external">Facebook App对TLS的魔改造：实现0-RTT</a></p>
<h1 id="Why-QUIC"><a href="#Why-QUIC" class="headerlink" title="Why QUIC"></a>Why QUIC</h1><p>从以上分析可以发现，HTTP2 和 SSL 可以说已经进行了大量的优化，可以提升的空间非常小。而 TCP 存在诸多不足之处，一方面它设计较早，而且主要目的是设计一种通用、可靠的传输协议，并非专门为网页或者 App 而设计，另一方面对 TCP 的改进要比对 SSL 和 HTTP 的改进麻烦的多，因为 TCP 是由各个操作系统实现，就以 TFO 为例吧，它在新版本的 Linux 内核中被实现，但想等到它普及开来就不知道要到猴年马月了，有兴趣的读者可以参考参考现在 Windows XP 系统的市场占有率。</p>
<p>反观 HTTP 和 SSL，虽然早期 HTTP 1.0 的问题更多，但是经过 1.1、SPDY、2.0 等版本的更迭，已经非常优秀了。其中的根本原因还是在于 HTTP  和 SSL 位于应用层，优化升级比较容易实现，所以经过长年累月的优化升级，现在大部分瓶颈都集中于 TCP 层。但 TCP 不仅优化点较多，而且还不容易更新。那么能不能在传输层搞一个和 TCP、UDP 类似的协议呢？答案也是否定的，其实曾经有一个 SCTP 协议打算进行一系列优化，但并没有被广泛接受。这是因为数据在传输的过程中需要经过各个路由器，这些设备只能识别并解析 TCP 和 UDP 协议的数据包，无法解析新的协议。所以 SCTP 也只能用于内网的实验环境中。</p>
<p>TCP 要改进，但不方便改，新增一个协议又不被已有的设备支持，看起来唯一的方案就是使用 UDP 了。虽然 UDP 协议不保证数据可达性，但这也是 UDP 的优点所在，它天然支持 0-RTT 的通信，所以一个比较新颖激进的想法就冒出来了:</p>
<p><strong>采用 UDP 作为底层协议，在 UDP 之上实现数据可达性</strong></p>
<p>目前，QUIC 协议内置在 Chrome 浏览器中，每次更新只需要升级浏览器即可，在 2014 年前就已经迭代了 13 个版本。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，作为总结，我简单回答一下文章开头的几个问题:</p>
<ol>
<li>QUIC 协议有哪些优点，如何实现 0-RTT？<ol>
<li>QUIC 协议在传输层就支持多路复用，避免了队头阻塞问题。</li>
<li>QUIC 协议基于 UDP，更自由更高效</li>
<li>QUIC 协议借鉴了 TFO 的思想，支持会话上下文缓存，方便恢复，具备实现 0-RTT 的可能</li>
</ol>
</li>
<li>传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点？<ol>
<li>SSL 的会话恢复依然需要一个 RTT，而且难以合并到 TCP 层</li>
<li>TCP 的滑动窗口存在队头阻塞问题</li>
<li>TCP 的重传纠错会浪费一个 RTT</li>
</ol>
</li>
<li>为什么 Google 要另起炉灶，基于 UDP 去做？<ol>
<li>TCP 由操作系统实现，很难更新</li>
<li>UDP 非常高效，几乎没有性能负担</li>
<li>将 QUIC 嵌入到 Chrome 中可以方便后续的升级迭代</li>
</ol>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ol>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html?utm_source=tuicool" target="_blank" rel="external">图解SSL/TLS协议</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">SSL/TLS协议运行机制的概述</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113095&amp;idx=1&amp;sn=0f7beafe5f48b4fdcde5465373044eab" target="_blank" rel="external">Facebook App对TLS的魔改造：实现0-RTT</a></li>
<li><a href="https://www.youtube.com/watch?v=hQZ-0mXFmk8" target="_blank" rel="external">视频: QUIC: next generation multiplexed transport over UDP</a></li>
<li><a href="https://docs.google.com/document/d/1WJvyZflAO2pq77yOLbp9NsGjC1CHetAXV8I0fQe-B_U/edit#heading=h.o9jvitkc5d2g" target="_blank" rel="external">官方文档: QUIC Wire Layout Specification</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QUIC 协议是 Google 提出的一套开源协议，它基于 UDP 来实现，直接竞争对手是 TCP 协议。QUIC 协议的性能非常好，甚至在某些场景下可以实现 0-RTT 的加密通信。所以这篇文章主要讨论以下几个问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;QUIC 协议有哪些优点，如
    
    </summary>
    
    
      <category term="前端" scheme="http://fullstack.blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="网络" scheme="http://fullstack.blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>九个问题从入门到熟悉HTTPS </title>
    <link href="http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/"/>
    <id>http://fullstack.blog/2017/03/12/九个问题从入门到熟悉HTTPS/</id>
    <published>2017-03-12T10:23:56.000Z</published>
    <updated>2017-03-12T11:01:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>女朋友也是软件工程专业，因为快要毕业了，最近一边做毕设一边学习编程。前两天她问我 HTTPS 的问题，本来想直接扔一篇网上的教程给她。后来想了一下，那些文章大多直接介绍概念， 对新手不太友好，于是我干脆亲自给她解释一下，顺便整理了一份问答录。</p>
<h3 id="Q1-什么是-HTTPS？"><a href="#Q1-什么是-HTTPS？" class="headerlink" title="Q1: 什么是 HTTPS？"></a>Q1: 什么是 HTTPS？</h3><h3 id="BS-HTTPS-是安全的-HTTP"><a href="#BS-HTTPS-是安全的-HTTP" class="headerlink" title="BS: HTTPS 是安全的 HTTP"></a>BS: HTTPS 是安全的 HTTP</h3><p>HTTP 协议中的内容都是明文传输，HTTPS 的目的是将这些内容加密，确保信息传输安全。最后一个字母 S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。</p>
<h3 id="Q2-你说的信息传输安全是什么意思"><a href="#Q2-你说的信息传输安全是什么意思" class="headerlink" title="Q2: 你说的信息传输安全是什么意思"></a>Q2: 你说的信息传输安全是什么意思</h3><h3 id="BS-信息传输的安全有三个方面"><a href="#BS-信息传输的安全有三个方面" class="headerlink" title="BS: 信息传输的安全有三个方面:"></a>BS: 信息传输的安全有三个方面:</h3><ol>
<li>客户端和服务器直接的通信只有自己能看懂，即使第三方拿到数据也看不懂这些信息的真实含义。</li>
<li>第三方虽然看不懂数据，但可以 XJB 改，因此客户端和服务器必须有能力判断数据是否被修改过。</li>
<li>客户端必须避免中间人攻击，即除了真正的服务器，任何第三方都无法冒充服务器。</li>
</ol>
<p>很遗憾的是，目前的 HTTP 协议还不满足上述三条要求中的任何一条。</p>
<h3 id="Q3-这么多要求，一个一个去满足是不是很累？"><a href="#Q3-这么多要求，一个一个去满足是不是很累？" class="headerlink" title="Q3: 这么多要求，一个一个去满足是不是很累？"></a>Q3: 这么多要求，一个一个去满足是不是很累？</h3><h3 id="BS-不累，第三个要求可以不用管"><a href="#BS-不累，第三个要求可以不用管" class="headerlink" title="BS: 不累，第三个要求可以不用管"></a>BS: 不累，第三个要求可以不用管</h3><p>是的，我没开玩笑，你可以暂时别管第三个要求，因为它实际上隶属于第一个需求。我们都知道加密需要密码，密码不是天下掉下来，也得需要双方经过通信才能协商出来。所以一个设计良好的加密机制必然会防止第三者的干扰和伪造。等搞明白了加密的具体原理，我们自然可以检验是否满足:“任何第三者无法冒充服务器”这一要求。</p>
<h3 id="Q4-那怎么加密信息呢"><a href="#Q4-那怎么加密信息呢" class="headerlink" title="Q4: 那怎么加密信息呢"></a>Q4: 那怎么加密信息呢</h3><h3 id="BS-使用对称加密技术"><a href="#BS-使用对称加密技术" class="headerlink" title="BS: 使用对称加密技术"></a>BS: 使用对称加密技术</h3><p>对称加密可以理解为对原始数据的可逆变换。比如 <code>Hello</code> 可以变换成 <code>Ifmmp</code>，规则就是每个字母变成它在字母表上的后一个字母，这里的秘钥就是 <code>1</code>，另一方拿到 <code>Ifmmp</code> 就可以还原成原来的信息 <code>Hello</code> 了。</p>
<p>引入对称加密后，HTTPS 的握手流程就会多了两步，用来传递对称加密的秘钥:</p>
<ol>
<li>客户端: 你好，我需要发起一个 HTTPS 请求</li>
<li>服务器: 好的，你的秘钥是 <code>1</code>。</li>
</ol>
<p>提到了对称加密，那么自然还有非对称加密。它的思想很简单，计算两个质数的乘积很容易，但反过来分解成两个质数的乘积就很难，要经过极为复杂的运算。非对称加密有两个秘钥，一个是公钥，一个是私钥。公钥加密的内容只有私钥可以解密，私钥加密的内容只有公钥可以解密。一般我们把服务器自己留着，不对外公布的密钥称为<strong>私钥</strong>，所有人都可以获取的称为<strong>公钥</strong>。</p>
<p>使用对称加密一般要比非对称加密快得多，对服务器的运算压力也小得多。</p>
<h3 id="Q5-对称秘钥如何传输"><a href="#Q5-对称秘钥如何传输" class="headerlink" title="Q5: 对称秘钥如何传输"></a>Q5: 对称秘钥如何传输</h3><p>服务器直接返回明文的对称加密密钥是不是不安全。如果有监听者拿到这个密钥，不就知道客户端和服务器后续的通信内容了么？</p>
<h3 id="BS-利用非对称加密"><a href="#BS-利用非对称加密" class="headerlink" title="BS: 利用非对称加密"></a>BS: 利用非对称加密</h3><p>是这样，所以不能明文传递对称秘钥，而且也不能用一个新的对称加密算法来加密原来的对称秘钥，否则新的对称秘钥同样无法传输，这就是鸡生蛋、蛋生鸡的悖论。</p>
<p>这里我们引入非对称加密的方式，非对称加密的特性决定了服务器用私钥加密的内容并不是<strong>真正的加密</strong>，因为公钥所有人都有，所以服务器的密文能被所有人解析。但私钥只掌握在服务器手上，这就带来了两个巨大的优势:</p>
<ol>
<li>服务器下发的内容不可能被伪造，因为别人都没有私钥，所以无法加密。强行加密的后果是客户端用公钥无法解开。</li>
<li>任何人用公钥加密的内容都是绝对安全的，因为私钥只有服务器有，也就是只有真正的服务器可以看到被加密的原文。</li>
</ol>
<p>所以传输对称秘钥的问题就迎刃而解了: 秘钥不是由服务器下发，而是由客户端生成并且主动告诉服务器。</p>
<p>所以当引入非对称加密后，HTTPS 的握手流程依然是两步，不过细节略有变化:</p>
<ol>
<li>客户端: 你好，我需要发起一个 HTTPS 请求，这是我的 (用公钥加密后的) 秘钥。</li>
<li>服务器: 好的，我知道你的秘钥了，后续就用它传输。</li>
</ol>
<h3 id="Q5-那公钥怎么传输"><a href="#Q5-那公钥怎么传输" class="headerlink" title="Q5: 那公钥怎么传输"></a>Q5: 那公钥怎么传输</h3><p>你好像还是没有解决鸡生蛋，蛋生鸡的问题。你说客户端发送请求时要用公钥加密对称秘钥，那公钥怎么传输呢？</p>
<h3 id="BS-对公钥加密就行了。。。"><a href="#BS-对公钥加密就行了。。。" class="headerlink" title="BS: 对公钥加密就行了。。。"></a>BS: 对公钥加密就行了。。。</h3><p>每一个使用 HTTPS 的服务器都必须去专门的证书机构注册一个证书，证书中存储了用权威机构私钥加密的公钥。这样客户端用权威机构的公钥解密就可以了。</p>
<p>现在 HTTPS 协议的握手阶段变成了四步:</p>
<ol>
<li>客户端: 你好，我要发起一个 HTTPS 请求，请给我公钥</li>
<li>服务器: 好的，这是我的证书，里面有加密后的公钥</li>
<li>客户端: 解密成功以后告诉服务器: 这是我的 (用公钥加密后的) 对称秘钥。</li>
<li>服务器: 好的，我知道你的秘钥了，后续就用它传输。</li>
</ol>
<h3 id="Q6-你在逗我么。。。。"><a href="#Q6-你在逗我么。。。。" class="headerlink" title="Q6: 你在逗我么。。。。"></a>Q6: 你在逗我么。。。。</h3><p>那权威机构的公钥又怎么传输？</p>
<h3 id="BS-存在电脑里"><a href="#BS-存在电脑里" class="headerlink" title="BS: 存在电脑里"></a>BS: 存在电脑里</h3><p>这个公钥不用传输，会直接内置在各大操作系统(或者浏览器)的出厂设置里。之所以不把每个服务器的公钥内置在电脑里，一方面是因为服务器太多，存不过来。另一方面操作系统也不信任你，凭什么你说你这个就是百度/淘宝的证书呢？</p>
<p>所以各个公司要先去权威机构认证，申请证书，然后操作系统只会存储权威机构的公钥。因为权威机构数量有限，所以操作系统厂商相对来说容易管理。如果这个权威机构不够权威，XJB 发证书，就会取消他的资格，比如可怜的沃通。。。。</p>
<h3 id="Q7-怎么知道证书有没有被篡改？"><a href="#Q7-怎么知道证书有没有被篡改？" class="headerlink" title="Q7: 怎么知道证书有没有被篡改？"></a>Q7: 怎么知道证书有没有被篡改？</h3><p>你说服务器第一次会返回证书，也就是加密以后的公钥，那我怎么知道这个证书是可靠的？</p>
<h3 id="BS-将信息-hash-值随着信息一起传递"><a href="#BS-将信息-hash-值随着信息一起传递" class="headerlink" title="BS: 将信息 hash 值随着信息一起传递"></a>BS: 将信息 hash 值随着信息一起传递</h3><p>我们都知道哈希算法的特点，它可以压缩数据，如果从函数角度来看，不管多复杂的数据(定义域可以非常大)经过哈希算法都会得到一个值，而且这个值处在某个特定(远小于定义域的范围)值域内。相同数据的哈希结果一定相同，不相同数据的哈希结果一般不同，不过也有小概率会重复，这叫哈希冲突。</p>
<p>为了确保原始证书没有被篡改，我们可以在传递证书的同时传递证书的哈希值。由于第三者无法解析数据，只能 XJB 改，那么修改后的数据在解密后，就不可能通过哈希。</p>
<p>比如说公钥就是之前的例子 <code>Hello</code>，我们假设哈希算法是获取字符串的最后一个字符，那么 <code>Hello</code> 的哈希值就是 <code>o</code>，所以加密字符串是 <code>Ifmmpp</code>。虽然公钥已知，每个人都可以解密，解密完也可以篡改，但是因为没有私钥， 所以无法正确的加密。所以它再返回给客户端的数据是无效数据，用公钥解析后会得到乱码。即使攻击者通过多次尝试碰巧能够解析，也无法通过哈希校验。</p>
<h3 id="Q8-这样可以防止第三方冒充服务器么"><a href="#Q8-这样可以防止第三方冒充服务器么" class="headerlink" title="Q8: 这样可以防止第三方冒充服务器么"></a>Q8: 这样可以防止第三方冒充服务器么</h3><h3 id="BS-也许可以"><a href="#BS-也许可以" class="headerlink" title="BS: 也许可以"></a>BS: 也许可以</h3><p>首先真正的服务器下发的内容，无法被别人篡改。他们有权威机构的公钥，所以可以解密，但是因为没有私钥，所以解密以后的信息无法加密。没有加密或者错误加密的信息被客户端用公钥解密以后，必然无法通过哈希校验。</p>
<p>但是，如果你一开始请求的就不是真的服务器，而是一个攻击者，此时的他完全有机会进行中间人攻击。我们知道第一次握手的时候服务器会下发用于证明自己身份的证书，这个证书会用预设在设备上的公钥来解密。所以要么是经过认证的证书用权威机构的私钥加密，再用权威机构解密，要么是用非权威机构的私钥加密，然后找不到公钥解密。</p>
<p>所以如果不小心安装过非权威机构的根证书，比如黑客提供的恶意证书，这时候设备上就多了一个预设的公钥，那么用恶意私钥加密的证书就能被正常解析出来。所以千万不要随便装根证书，这等于是为那些恶意证书留了一扇门。</p>
<p>当然，凡是都有两面性。我们知道 Charles 可以调试 HTTPS 通信，它的原理就是需要用户安装 Charles 的根证书，然后我们的请求会被代理到 Charles 服务器，它下发的 Charles 证书才能被正确解析。另一方面，Charles 会作为客户端，从真正的服务器哪里拿到正确的 https 证书并用于后续通信。幸好 Charles 不是流氓软件，或者它的私钥一旦泄露，对用户都会造成很大的影响。</p>
<p>我可以举一个例子，证书有多个种类，最贵的叫 EV (Extended Validation)，它需要公司营业执照等多个文件才能申请人工审核，好处也很明显，可以在浏览器地址栏左侧准确显示公司名称，比如 <a href="https://bitbucket.org/" target="_blank" rel="external">Bitbucket 的官网</a>:</p>
<p><img src="http://images.bestswifter.com/1489308655.png" alt="EV 证书左侧的名字"></p>
<p>这是客户端直连时候的正常现象。但如果你用 Charles 代理，客户端拿到的是 Charles 证书，所以会变成: </p>
<p><img src="http://images.bestswifter.com/1489308747.png" alt="代理模式下无法显示"></p>
<h3 id="Q9-HTTPS-握手会影响性能么"><a href="#Q9-HTTPS-握手会影响性能么" class="headerlink" title="Q9: HTTPS 握手会影响性能么"></a>Q9: HTTPS 握手会影响性能么</h3><p>TCP 有三次握手，再加上 HTTPS 的四次握手，会不会影响性能？</p>
<h3 id="BS-影响肯定有，但是可以接受"><a href="#BS-影响肯定有，但是可以接受" class="headerlink" title="BS: 影响肯定有，但是可以接受"></a>BS: 影响肯定有，但是可以接受</h3><p>首先，HTTPS 肯定会更慢一点，时间主要花费在两组 SSL 之间的耗时和证书的读取验证上，对称算法的加解密时间几乎可以忽略不计。</p>
<p>而且如果不是首次握手，后续的请求并不需要完整的握手过程。客户端可以把上次的加密情况直接发送给服务器从而快速恢复，具体细节可以参考 <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">图解SSL/TLS协议</a>。</p>
<p>除此以外，SSL 握手的时间并不是只能用来传递加密信息，还可以承担起客户端和服务器沟通 HTTP2 兼容情况的任务。因此从 HTTPS 切换到 HTTP2.0 不会有任何性能上的开销，反倒是得益于 HTTP2.0 的多路复用等技术，后续可以节约大量时间。</p>
<p>如果把 HTTPS2.0 当做目标，那么 HTTPS 的性能损耗就更小了，远远比不上它带来的安全性提升。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>相信以上九个问题足够帮助新人了解 HTTPS 了，但这只是基本概念，关于 HTTPS 的使用(比如 iOS 上的一些具体问题)还需要不断尝试和研究。</p>
<p>文章最后打一个求职广告，长期有效，女朋友今年毕业，考研 380+，<a href="https://github.com/tinycat2017/Resume" target="_blank" rel="external">简历戳这里</a>，计算机基础还算扎实，但项目经验偏少，可以实习 6 个月以上。北京地区如果有想要招实习生的公司，欢迎联系我，方向不限，前后端皆可培养，iOS 更好(我自己教)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;女朋友也是软件工程专业，因为快要毕业了，最近一边做毕设一边学习编程。前两天她问我 HTTPS 的问题，本来想直接扔一篇网上的教程给她。后来想了一下，那些文章大多直接介绍概念， 对新手不太友好，于是我干脆亲自给她解释一下，顺便整理了一份问答录。&lt;/p&gt;
&lt;h3 id=&quot;Q1-
    
    </summary>
    
    
      <category term="前端" scheme="http://fullstack.blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>业务爬坑与总结——开屏广告热启动实现方案</title>
    <link href="http://fullstack.blog/2017/03/09/%E4%B8%9A%E5%8A%A1%E7%88%AC%E5%9D%91%E4%B8%8E%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%BC%80%E5%B1%8F%E5%B9%BF%E5%91%8A%E7%83%AD%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>http://fullstack.blog/2017/03/09/业务爬坑与总结——开屏广告热启动实现方案/</id>
    <published>2017-03-09T03:51:07.000Z</published>
    <updated>2017-03-09T05:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>最初接下开屏广告热启动需求时，对于即将踏入一个什么样的深坑，我心里毫无概念。在当时看来，开屏广告的相关代码已经基本实现，我只要额外添加热启动功能就可以，即使算上调研设计、后端联调加上测试的时间，我也只给自己规划了一周多的时间来完成双端的需求。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>所谓的开屏广告热启动是指，应用程序进入后台后(按 Home 键或者跳转到其他应用)，等待一段时间再回到应用时展示开屏广告。由于操作系统会定时清理不活跃且占内存的应用，所以此时展示开屏广告会让用户以为应用正在重新启动。由于对用户体验伤害小，甚至很多时候几乎可以做到无感知，所以目前很多日活量较高的 app 都实现了开屏广告热启动功能，常见的有微博、头条等。</p>
<p>如果不考虑最短间隔时间，每天热启动次数上限等附加限制，开屏广告热启动的核心需求其实就在于<strong>准确地检测应用切到后台再回到前台</strong>的行为。所谓的准确，指的是不漏掉真正的进入后台，也不误把普通操作当做进入后台。</p>
<p>这个需求看上去非常容易，直接调用系统 API 即可完成，而在实际开发的过程中却遇到了不少坑，我按照平台逐一分析一下，不会有太多的实现细节，主要是聊聊设计和实现思路。</p>
<h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>先说我最熟悉的，也是相对来说比较容易实现的 iOS 平台。</p>
<p>在实现开屏广告需求时，从设计角度来考虑，由于 <code>application:didFinishLaunchingWithOptions:</code> 函数执行结束后会自动发送通知，所以我们只需要监听 <code>UIApplicationDidFinishLaunchingNotification</code> 通知即可。在展示广告时，可以使用 <code>UIView</code> 直接盖上一张图片。不过考虑到有倒计时按钮，跳过按钮，以及将来有可能支持除了图片以外的其他格式(比如 VR 视频)，所以使用 <code>UIViewController</code> 虽然麻烦些，但也不失为一种稳妥的，方便后续拓展维护的做法。</p>
<p>具体做法就不详细描述了，感兴趣的读者可以参考 <a href="http://www.cocoachina.com/ios/20160628/16828.html" target="_blank" rel="external">无入侵的开屏广告插入方式</a>。</p>
<p>前文说过热启动需要满足一定条件，比如进入后台和再次回到前台的时间间隔必须大于某个值，否则回到桌面后快速返回应用也会出现开屏广告，带给用户的体验很差。并且这个值最好是做成服务器动态下发，好处是一旦开屏广告的逻辑出现问题，可以把间隔时间设为非常大的值，从而关闭此功能。同样是出于用户体验考虑，每天开屏广告热启动的次数也需要做限制，超出预设次数以后不再展示。</p>
<p>为了管理以上逻辑，并且与原有开屏广告逻辑有效解耦，单独抽离一个 <code>HotSplashManager</code> 类就显得很有必要。由于应用的整个生命周期内都有可能展示开屏广告，所以可以考虑设计为单例模式，并且对外统一暴露一个 <code>- (BOOL)canShowHotSplashAdvertisement</code> 方法。</p>
<p>不过由于目前项目中没有使用通知，而是与 <code>application:didFinishLaunchingWithOptions:</code> 方法强耦合。所以我接手以后的思路也是沿用前人的代码，主要是在 <code>applicationDidEnterBackground</code> 函数中通知 <code>HotSplashManager</code> 类应用进入后台。</p>
<h2 id="锁屏检测"><a href="#锁屏检测" class="headerlink" title="锁屏检测"></a>锁屏检测</h2><p>这里的第一个小坑在于锁屏同样会触发 <code>applicationDidEnterBackground</code> 函数，而从逻辑上讲，应用锁屏后再解锁并不应该被认为是一种前后台切换，而如果<strong>已经按 Home 键进入后台</strong>，这时候再锁屏/解锁就不应该影响 App <strong>进入了后台再切回前台</strong>的事实，也就是不影响开屏广告的正常展示，这里的逻辑比较绕，需要整理一下逻辑并仔细测试。</p>
<p>检测锁屏和解锁的方法有好几种， 其中有的方法不能完全兼容 iOS 9、10 两大主流版本。最终找到的有效方案是利用 Darwin 层面的通知:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 检测锁屏和解锁</span></div><div class="line"><span class="built_in">CFNotificationCenterAddObserver</span>(<span class="built_in">CFNotificationCenterGetDarwinNotifyCenter</span>(), <span class="comment">//center</span></div><div class="line">                                <span class="literal">NULL</span>, <span class="comment">// observer</span></div><div class="line">                                displayStatusChanged,</div><div class="line">                                <span class="built_in">CFSTR</span>(<span class="string">"com.apple.springboard.lockstate"</span>),</div><div class="line">                                <span class="literal">NULL</span>, <span class="comment">// object</span></div><div class="line">                                <span class="built_in">CFNotificationSuspensionBehaviorDeliverImmediately</span>);</div><div class="line">                                </div><div class="line"><span class="comment">// 接受通知后的处理</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> displayStatusChanged(<span class="built_in">CFNotificationCenterRef</span> center,</div><div class="line">                                 <span class="keyword">void</span> *observer,</div><div class="line">                                 <span class="built_in">CFStringRef</span> name,</div><div class="line">                                 <span class="keyword">const</span> <span class="keyword">void</span> *object,</div><div class="line">                                 <span class="built_in">CFDictionaryRef</span> userInfo) &#123;</div><div class="line">    <span class="comment">// 每次锁屏和解锁都会发这个通知，第一次是锁屏，第二次是解锁，交替进行</span></div><div class="line">    [[HotSplashManager sharedInstance] lockStateChanged];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不是我的使用方式有误，那么理论上来说是拿不到准确的锁屏 or 解锁状态的，只能知道每次解锁或者锁屏都会触发这个通知，并且第一次一定是锁屏，往后依次交替，所以要在自己的 <code>HotSplashManager</code> 中管理好屏幕状态。</p>
<h2 id="自然日缓存"><a href="#自然日缓存" class="headerlink" title="自然日缓存"></a>自然日缓存</h2><p>每天展示次数有上限就意味着展示次数必须被持久化保存在本地，这可以理解为一种特殊的缓存:“仅在一个自然日内有效，跨日自动清空”。考虑到这样的需求并不是开屏广告这个业务独有，所以不妨抽取成一个基础类: <code>XXXDailyCache</code>，并且给它一个 <code>namespace</code> 的概念来针对不同业务做隔离。</p>
<p>需要强调的是，虽然很多项目都会实现自己的基础缓存类 <code>XXXCache</code>，这里我强烈反对使用继承模式，感兴趣的读者可以参考我之前的文章: <a href="https://bestswifter.com/pop/#" target="_blank" rel="external">从 Swift 的面向协议编程说开去</a> 一文的倒数第二节: “继承与组合”，说的就是这种非常常见的误用继承关系的场景。所以这里正确的做法是使用组合模式，用 <code>namespace</code> 去创建基础的 <code>XXXCache</code> 类实现缓存功能，而 <code>DailyCache</code> 则持有缓存对象并且实现按自然日删除的逻辑。</p>
<p>按自然日区分的逻辑很简单， 只要把缓存的 Key 设置为当前日期，然后每次读取之前先判断日期即可。这是比较简单的体力活，就不多费口舌了。封装得好的话，只会对外暴露三个简洁方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXXDailyCache</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithNameSpace:(<span class="built_in">NSString</span> *)namespace;</div><div class="line">- (<span class="keyword">id</span>)getValueWithKey(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)writeWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="keyword">id</span>)value;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="开屏广告热启动"><a href="#开屏广告热启动" class="headerlink" title="开屏广告热启动"></a>开屏广告热启动</h2><p>之前的同事已经实现了开屏广告功能，他们提供了一个 <code>showSplashAD</code> 的方法，方法内部会把根 <code>UIView</code> 的 <code>rootViewController</code> 设置为开屏广告的 ViewController。</p>
<p>现在添加好了相关判断条件以后，只需要简单改造一下 app 进入前台的回调即可，对原来业务的改动相对来说很小:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    <span class="keyword">if</span> ([[HotSplashManager sharedInstance] canShowSplashAd]) &#123;</div><div class="line">        [<span class="keyword">self</span> showSplashAD];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总的来说 iOS 的实现相当简单， 做好基础类的封装，注意判断一下锁屏问题就可以了。</p>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>首先 iOS 存在的问题安卓都有，所以同样需要封装自然日失效的 <code>DailyCache</code>，处理锁屏逻辑则是使用了通知机制，监听系统的通知。</p>
<p>为了可复用性，我们可以封装出一个单独的类来监听锁屏通知，并记录当前状态，以便将来可以对外提供相应的服务:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenLockReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isScreenOff = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) &#123;</div><div class="line">            isScreenOff = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) &#123;</div><div class="line">            isScreenOff = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实例化这个 <code>ScreenLockReceiver</code> 并为它添加好过滤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ScreenLockReceiver screenLockReceiver = <span class="keyword">new</span> ScreenLockReceiver();</div><div class="line">IntentFilter lockFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line">lockFilter.addAction(Intent.ACTION_SCREEN_ON);</div><div class="line">lockFilter.addAction(Intent.ACTION_SCREEN_OFF);</div><div class="line">lockFilter.addAction(Intent.ACTION_USER_PRESENT);</div><div class="line">registerReceiver(screenLockReceiver, lockFilter);</div></pre></td></tr></table></figure>
<h2 id="前后台切换"><a href="#前后台切换" class="headerlink" title="前后台切换"></a>前后台切换</h2><p>由于安卓没有提供系统级别的前后台切换通知，所以不得不自己手动实现。第一种思路是实现 <code>onTrimMemory</code> 函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (level == ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) &#123;</div><div class="line">        <span class="comment">// Get called every-time when application went to background.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的原理来源于官网对于 <code>onTrimMemory</code> 的解释，当 level 的值是 <code>TRIM_MEMORY_UI_HIDDEN</code> 时，按照文档的解释是应用程序进入后台，需要释放 UI 资源。基于这种思路的前后台切换检测在 <a href="http://stackoverflow.com/a/19920353" target="_blank" rel="external">Stack Overflow</a> 上得到了非常多的赞同。然而根据我们的测试，在某些高端机型上，即使应用程序进入后台，由于内存相对充足，并不会触发上述方法。</p>
<p>考虑到官方文档没有明确说明进入后台时一定会调用 <code>onTrimMemory</code> 方法， 很多时候是开发者自己的总结，我们最终放弃了这种实现思路。</p>
<p>实际上还有一种最老土，也相对来说最准确的判断方法。应用进入后台时，Activity 会调用 <code>onPause</code> 方法，回到前台又会调用 <code>onResume</code> 方法。虽然在切换 Activity 时也会走这样的流程，但是两个方法的调用时间间隔非常短，即使考虑到低端机的性能问题， 两秒钟也足够完成一次页面跳转了。所以只需要记录 <code>onPause</code> 的时间戳，再拿到 <code>onResume</code> 的时间戳，两者做差比较即可。</p>
<p>如果之前的应用封装的好的话，应该会有一个继承自系统的 <code>Activity</code> 的子类，比如叫做 <code>BaseActivity</code>。显然以上逻辑应该在这个 <code>BaseActivity</code> 里完成， 不过一个应用中并不一定所有的视图都继承自这个 <code>BaseActivity</code>，我们还有可能使用 <code>FragmentActivity</code> 及其子类，所以在对应的 <code>BaseFragmentActivity</code> 中也要添加类似的逻辑。</p>
<h2 id="展示开屏广告"><a href="#展示开屏广告" class="headerlink" title="展示开屏广告"></a>展示开屏广告</h2><p>与 iOS 不同的是，进入前台事件的直接处理逻辑应该写在 <code>HotSplashManager</code> 类中，而非 iOS 的 <code>Appdelegate</code>，唤起开屏广告的方式也略有不同。在 <code>HotSplashManager</code> 中我们可以直接拿到当前展示的 activity(<code>BaseActivity</code> 把自己传过来)，然后调用它的 <code>startActivity</code> 方法就可以唤起开屏广告所在的 Activity 了，注意关掉动画效果。</p>
<p>开屏广告的 <code>SplashActivity</code> 也需要对唤起方式做区分，判断自己是冷启动展示还是热启动展示。如果是热启动展示，不需要涉及后续的引导页流程，而是直接调用 <code>this.finish()</code> 即可。</p>
<h2 id="多进程通信"><a href="#多进程通信" class="headerlink" title="多进程通信"></a>多进程通信</h2><p>以上功能完成以后，基本上开屏广告热启动的需求就算开发完了，直到测试时有用户反馈全屏查看图片时大概率也会展示开屏广告。经过排查后发现，我们的应用中诸如查看图片、打开网页等操作都会放到其他进程中完成，从而避免与主进程争夺内存，导致 OOM。</p>
<p>多进程场景下会有多个 Application 和 Activity 实例在同时运行。在主进程切换到子进程的过程中，实际上调用到的是主进程的 <code>onPause</code> 和子进程的 <code>onResume</code>，子进程回到主进程时调用的则是子进程的 <code>onPause</code> 和主进程的 <code>onResume</code>。</p>
<p>不难看出对于主进程而言，<code>onPause</code> 和下一次 <code>onResume</code> 之前的时间间隔至少是在子进程中停留的时间。所以容易出现前后台切换的误报。</p>
<p>解决这个问题有多个思路，但任何基于 Application 类，利用内存存储数据的做法均不可能实现，应该避免在这种思路上浪费不必要的时间。首先可以考虑 AIDL、Binder 等多进程通信模型，不过网上搜了一圈，普遍实现起来比较啰嗦，而且实际上我这里的需求并不是通信，而是传递一个非常小的数据，表示 App 是否进入子进程，所以这些方案首先排除。</p>
<p>由于没有找到合适的跨进程内存共享方案，所以接下来考虑的是文件共享的方式，代表技术有 ContentProvider。不过 ContentProvider 实际上是对下层具体文件读写实现方案的抽象封装，提供了一套 CURD 接口。也就是说我还得自己实现文件的读写。考虑到实现成本过大，而需求比较简单，也排除了这种方案。</p>
<p>最后考虑到通知，先调研了 <code>LocalBroadcastManager</code> 这种本地通知，看了一下源码以后发现不适用于跨进程通信，内部其实是利用 <code>context</code> 参数拿到了 <code>ApplicationContext</code>，然后实现了简单的观察者模式。感兴趣的读者可以阅读文章末尾的参考资料。</p>
<p>最终的解决方案是选择了普通的 <code>BroadcastManager</code>，注意添加 filter 过滤一下，以及设置好包名，限制广播的接收者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(BROADCAST_KEY);</div><div class="line">intent.setPackage(getPackageName());</div><div class="line">intent.putExtra(<span class="string">"flag"</span>, <span class="keyword">false</span>);  <span class="comment">// 通知主进程 application: "已经进入子进程"</span></div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure>
<h2 id="其他的一些思考"><a href="#其他的一些思考" class="headerlink" title="其他的一些思考"></a>其他的一些思考</h2><p>开发过程中的坑远远不止上面列出的这些，比如还顺手解决了一个弱引用过早释放的 bug 和一个内存泄漏的问题。此外，在开发的过程中对 context 概念还比较模糊，Java 闭包对捕获的变量的处理也挺有意思，不过考虑到大部分都是 Java 语法，就不在这篇业务学习总结里面多啰嗦了，待我整理一下，另起一篇文章专门讨论。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://blog.csdn.net/xyz_fly/article/details/18970569" target="_blank" rel="external">Android编程之LocalBroadcastManager源码详解</a></li>
<li><a href="http://www.trinea.cn/android/localbroadcastmanager-impl/" target="_blank" rel="external">LocalBroadcastManager 的实现原理，还是 Binder？</a></li>
<li><a href="http://www.dundunwen.com/article/765314db-4072-4022-bb21-3f1e64ea54ba.html" target="_blank" rel="external">LocalBroadcastManager分析</a></li>
<li><a href="http://www.cocoachina.com/ios/20160628/16828.html" target="_blank" rel="external">无入侵的开屏广告插入方式</a></li>
<li><a href="http://stackoverflow.com/questions/4414171/how-to-detect-when-an-android-app-goes-to-the-background-and-come-back-to-the-fo" target="_blank" rel="external">How to detect when an Android app goes to the background and come back to the foreground</a></li>
<li><a href="https://gold.xitu.io/entry/57c3841d0a2b58006cf9f7f5" target="_blank" rel="external">Android 探索之 BroadcastReceiver 具体使用以及安全性探究</a></li>
</ol>
<p>以及其他阅读过但没有记录下来的优秀文章，感谢前辈们的分享。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最初接下开屏广告热启动需求时，对于即将踏入一个什么样的深坑，我心里毫无概念。在当时看来，开屏广告的相关代码已经基本实现，我只要额外添加热启动功能就可以，即使算上调研设计、后端联调加上测试的时间，我也只给自己规划了一周多的时间来完成双端的需求。&lt;/p&gt;
&lt;h1 id=&quot;需求&quot;
    
    </summary>
    
    
      <category term="Android" scheme="http://fullstack.blog/tags/Android/"/>
    
      <category term="Java" scheme="http://fullstack.blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>异步与回调的设计哲学</title>
    <link href="http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"/>
    <id>http://fullstack.blog/2017/02/26/异步与回调的设计哲学/</id>
    <published>2017-02-26T14:23:20.000Z</published>
    <updated>2017-02-26T14:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文的例子用 JavaScript 语法给出，希望读者至少有使用过 Promise 的经验，如果用过 async/await 则更好，对于客户端的开发者，我相信语法不是阅读的瓶颈，思维才是，因此也可以了解一下异步编程模型的演变过程。</p>
<h1 id="异步编程入门"><a href="#异步编程入门" class="headerlink" title="异步编程入门"></a>异步编程入门</h1><h2 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h2><p>CPS 的全称是 (Continuation-Passing Style)，这个名词听上去比较高大上(背后涉及到很多数学方面的东西)，实际上如果只是想了解什么是 CPS 的话，并不是太难。</p>
<p>我们看下面这段代码，你肯定会觉得太简单了:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int a = sum(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">// 第一行业务代码 </span></div><div class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 第二行业务代码</span></div></pre></td></tr></table></figure>
<p>隐藏在这两行代码背后的是串行编程的思想，也就是说第一行代码执行出结果以后才会执行第二行代码。</p>
<p>可如果 <code>sum</code> 这个函数耗时比较久怎么办呢，一般我们不会选择等待它执行完，而是提供一个回调，在执行完耗时操作以后再执行回调，同时避免阻塞主线程:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asum</span>(<span class="params">a, b, callback</span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> r = a + b;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		callback(r);</div><div class="line">	&#125;, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">asum(<span class="number">1</span>, <span class="number">2</span>, r =&gt; <span class="built_in">console</span>.log(r));</div></pre></td></tr></table></figure>
<p>于是，业务方不用等待 <code>asum</code> 的返回结果了，现在它只要提供一个回调函数。这种写法就叫做 CPS。</p>
<p>CPS 可以总结为一个很重要的思想: <strong>“我不用等执行结果，我先假设结果已经有了，然后描述一下如何利用这个结果，至于调用的时机，由结果提供方负责管理”</strong>。</p>
<h2 id="没什么卵用的-CPS"><a href="#没什么卵用的-CPS" class="headerlink" title="没什么卵用的 CPS"></a>没什么卵用的 CPS</h2><p>扯了这么多 CPS，其实我想说的是，很多介绍 Promise 的文章上来就谈 CPS，更有甚者直接聊起了 CPS 的背后数学模型。实际上 CPS 对异步编程没什么卵用，主要是它的概念太普遍，太容易理解了，我敢打赌几乎所有的开发者都或多或少的用过 CPS。</p>
<p>毕竟回调函调每个人都用过，只不过你不一定知道这是 CPS 而已。比如随便举一个 AFNetworking 中的例子:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>写过 JavaScript 的人应该都接触过 Promise，首先明确一个概念，Promise 是一些列规范的总称，现有的规范有 Promise/A、Promise/B、Promise/A+ 等等，每个规范都有自己的实现，当然也可以自己提供一个实现，只要能满足规范中的描述即可。</p>
<p>写过 Promise 或者 RAC/RxSwift 的读者估计对一长串 <code>then</code> 方法记忆深刻，不知道大家是否思考过，为什么会设计这种链式写法呢？</p>
<p>我当然不想听到什么“方法调用以后还返回自己”这种废话，要能反复调用 then 方法必然要返回同一个类的对象啊。。。要想搞清楚为什么要这么设计，或者为什么可以这么设计，我们先来看看传统的 CPS(基于回调) 写法如何处理嵌套的异步事件。</p>
<p>如果我需要请求第一个接口，并且用这个接口返回的数据请求下一个接口，那代码看起来大概是这样的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">request(url1, parms1, response =&gt; &#123;</div><div class="line">    <span class="comment">// 处理 response</span></div><div class="line">    request(url2, params2, response =&gt; &#123;</div><div class="line">        <span class="comment">// 处理第二个接口的数据</span></div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上述代码用伪代码写起来看上去还能接受，不过可以参考 OC 的繁琐代码，试想一个双层嵌套就已经如此麻烦， 三层嵌套该怎么写是好呢？</p>
<h2 id="CPS-的本质"><a href="#CPS-的本质" class="headerlink" title="CPS 的本质"></a>CPS 的本质</h2><p>我们抽象一下上面的逻辑，CPS 的含义是不直接等待异步数据返回，而是传入一个回调函数来处理未来的数据。换句话讲:</p>
<p><strong>回调事件是一个普通事件，内部可能还会发起一个异步事件</strong></p>
<p>这种世界观的好处在于，通过事件的嵌套形成了一套递归模型，理论上能够解决任意多层的嵌套。当然缺点也是显而易见的，<strong>语义上的嵌套最终导致了代码上的嵌套</strong>，影响了可读性和可维护性。</p>
<p>这种嵌套模型可以用下面这幅图来表示:</p>
<p><img src="http://images.bestswifter.com/1488098032.png" alt="CPS 回调的本质"></p>
<p>可以看到图中只有两种图形，椭圆形表示一般性事件(回调也是一个事件)，而圆角矩形表示一个异步过程，当执行完以后，就会接着执行它连接着的事件。</p>
<h2 id="Promise-的本质"><a href="#Promise-的本质" class="headerlink" title="Promise 的本质"></a>Promise 的本质</h2><p>当然，我们是有办法解决嵌套问题的，俗话说得好:</p>
<blockquote>
<p>任何计算机问题都可以通过添加一个中间层来解决</p>
</blockquote>
<p>而 Promise 的本质则是下面这幅图:</p>
<p><img src="http://images.bestswifter.com/1488098234.png" alt="Promise 的本质"></p>
<p>可以看到，我们引入了新的 Promise 层，一个 Promise 内部封装了异步过程，和异步过程结束以后的回调。如果这个回调的内部可以生成一个新的 Promise。于是嵌套模型就变成了链式模型，这也是为什么我们经常能看到 <code>then</code> 方法的调用链。</p>
<p>需要强调的是，即使你用了 Promise，也可以在回调函数中直接执行异步过程，这样就回到了嵌套模型。所以 Promise 的精髓实际上在于回调函数中返回一个新的 Promise 对象。</p>
<h2 id="Promise-的基本概念"><a href="#Promise-的基本概念" class="headerlink" title="Promise 的基本概念"></a>Promise 的基本概念</h2><p>数据结构学得好的读者看到上面这幅图应该会想到链表。不过一个 Promise 内部可以持有多个新的 Promise，所以采用的不是链表结构而是有些类似于多叉树。简化版的 Promise 定义如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">resolver</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.state = PENDING;</div><div class="line">  <span class="keyword">this</span>.value = <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.queue = [];   <span class="comment">// 持有接下来要执行的 promise</span></div><div class="line">  <span class="keyword">if</span> (resolver !== INTERNAL) &#123;</div><div class="line">    safelyResolveThen(<span class="keyword">this</span>, resolver);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对一个 Promise 对象调用 <code>then</code> 方法，实际上是判断 Promise 的状态是否还是 <code>PENDING</code>，如果是的话就生成一个新的 Promise 保存在数组中。否则直接执行 then 方法参数中 block。</p>
<p>当一个 Promise 内部执行完以后，比如说是进入了 <code>FULLFILLED</code> 状态，就会遍历自己持有的所有的 Promise 并告诉他们也去执行 <code>resolve</code> 方法，进入 <code>REJECTED</code> 状态也是同理。</p>
<p>如果能够理解这层思想，你就可以理解为什么有前后关系顺序的几个异步事件可以用 <code>then</code> 这种同步写法串联了。因为调用 <code>then</code> 实际上是预先保留了一个回调，只有当上一个 Promise 结束以后才会通知到下一个 Promise。</p>
<h2 id="Promise-小细节"><a href="#Promise-小细节" class="headerlink" title="Promise 小细节"></a>Promise 小细节</h2><p>关于 Promise 的实现原理，这篇文章不想描述太多，感兴趣的读者可以参考 <a href="https://zhuanlan.zhihu.com/p/25178630" target="_blank" rel="external">深入 Promise(一)——Promise 实现详解</a>，读完以后可以看一下作者的后续文章中的四个题目，检验一下是否真的理解了: <a href="https://zhuanlan.zhihu.com/p/25198178" target="_blank" rel="external">深入 Promise(二)——进击的 Promise</a>。</p>
<p>这里我只想强调一下几个容易理解错的地方。首先，Promise 会接受一个函数作为自己的参数，也就是下面代码中的 <code>fucntion (resolve, reject){ /* do something */ }</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p =	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">	resolve(<span class="string">'hello'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(ppppp);</div><div class="line"><span class="comment">// 打印出 Promise &#123; 'hello' &#125; 而不是 Promise &#123; 'pedding' &#125;</span></div><div class="line"><span class="comment">// 证明 Promise 已经在创建时就决议</span></div></pre></td></tr></table></figure>
<p>在创建 Promise 时，这个参数函数就会被执行， 执行这个函数需要两个参数 <code>resoleve</code> 和 <code>reject</code>，它并不是通过 <code>then</code> 方法提供而是由 Promise 在内部自己提供，换句话说这两个参数是已知的。</p>
<p>因此如果按照上述代码来写， 在创建 Promise 时就会立刻调用 <code>resolve(&#39;hello&#39;)</code>，然后把状态标记为 <code>FULLFILLED</code> 并且让内部的 <code>value</code> 值为 <code>&quot;hello&quot;</code>。这样后来执行 <code>then</code> 的时候会判断到 Promise 已经决议，直接把 <code>value</code> 的值放到 then 的闭包中，而且这个过程是异步执行(参考文章中 immediate 的使用)。</p>
<p>有的文章会谈到 Promise 的错误处理，实际上这里没有什么高深的学问或者黑科技。如果在 Promise 内部调用 <code>setTimeout</code> 异步的抛出错误，外面还是接不到。</p>
<p>Promise 处理错误的原则是提供了一个 <code>reject</code> 回调，并且用 <code>reject</code> 方法来代替抛出错误的做法。这样做相当于约定了一套错误协议，把错误直接转嫁到业务方的逻辑中。</p>
<p>另一个需要重点理解的是 <code>then</code> 方法提供的闭包中，返回的内容，因为这才是链式模型的核心。</p>
<p>在 Promise 内部的 <code>doResolve</code> 方法中会有以下关键判断:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> then = getThen(value);</div><div class="line"><span class="keyword">if</span> (then) &#123;</div><div class="line">    safelyResolveThen(self, then);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    self.state = FULFILLED;</div><div class="line">    self.value = value;</div><div class="line">    self.queue.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">queueItem</span>) </span>&#123;</div><div class="line">    queueItem.callFulfilled(value);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此如果这里的 value 不是基本类型，就会重新走一遍 <code>safelyResolveThen</code>，相当于重新解一遍 Promise 了。</p>
<p>所以正确的异步嵌套逻辑应该是: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p =	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">	resolve(<span class="string">'hello'</span>);</div><div class="line">&#125;)</div><div class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(value);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		resolve(<span class="string">'world'</span>)</div><div class="line">	&#125;);</div><div class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 第一行打印出 hello</span></div><div class="line"><span class="comment">// 第二行打印出 world</span></div></pre></td></tr></table></figure>
<h1 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h1><p>我们先看一个 Python 中的例子，如何打印斐波那契数列的前五个元素:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span> </div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </div><div class="line">    <span class="keyword">while</span> n &lt; max: </div><div class="line">        <span class="keyword">print</span> b </div><div class="line">        a, b = b, a + b </div><div class="line">        n = n + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>得益于 Python 简洁的语法，函数实现仅用了六行代码:</p>
<p><img src="http://images.bestswifter.com/1488103781.png" alt="fab 函数"></p>
<p>不过缺点在于， 每次调用函数都会打印所有数字，不能实现按需打印:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>): </div><div class="line">    <span class="keyword">print</span> n</div></pre></td></tr></table></figure>
<p>我们先不考虑为什么 <code>fab(5)</code> 能放在 <code>in</code> 关键字后面，至少能分次打印就意味着我们需要一个对象，内部保存上一次的结果，这样才能正确的生成下一个值。</p>
<p>感兴趣的读者可以用对象来实现一下上述需求， 并且对比一下引入对象后带来的复杂度增加。一种既不增加复杂度，也能保留上下文的技术是使用生成器，只需要修改一个单词即可:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span> </div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </div><div class="line">    <span class="keyword">while</span> n &lt; max: </div><div class="line">        <span class="keyword">yield</span> b  <span class="comment">#原来是 print b</span></div><div class="line">        a, b = b, a + b </div><div class="line">        n = n + <span class="number">1</span></div></pre></td></tr></table></figure>
<p><code>yield</code> 关键字的含义是 <strong>当外界调用 next 方法时生成器内部开始执行，直到遇到 yield 关键字，此时把 yield 后面的值传递出去作为 next() 的结果，然后继续执行函数，直到再次遇到 yield 方法时暂停</strong>。</p>
<h2 id="Generator-in-JavaScript"><a href="#Generator-in-JavaScript" class="headerlink" title="Generator in JavaScript"></a>Generator in JavaScript</h2><p>上面举 Python 的例子是因为生成器在 Python 中最为简单，最好理解。在 JavaScript 中，生成器的概念稍微复杂一点，主要涉及两个变化。</p>
<ol>
<li>要求在 function 后面加上星号(*) 表示这是一个生成器而不是普通函数。</li>
<li><code>next()</code> 方法可以传递参数，在生成器内部表现为 yield 的返回值。</li>
</ol>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">count</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(count);</div><div class="line">	<span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="number">100</span></div><div class="line">	<span class="built_in">console</span>.log(result + count);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> g = generator(<span class="number">2</span>);  <span class="comment">// 什么都不输出</span></div><div class="line"><span class="built_in">console</span>.log(g.next().value);  <span class="comment">// 第一次打印 2，随后打印 100</span></div><div class="line">g.next(<span class="number">9</span>); <span class="comment">// 打印 11</span></div></pre></td></tr></table></figure>
<p>逐行解释一下:</p>
<ol>
<li>调用 <code>generator</code> 时，生成器并没有执行，所以什么都没有输出。</li>
<li>调用 <code>g.next</code> 时，函数开始执行，打印 <code>2</code>，遇到 yield，拿到了 yield 生成的内容，也就是 100，传递给 <code>next()</code> 的调用结果，所以第二行打印 100。</li>
<li>再次调用 <code>next()</code> 方法，生成器内部恢复执行，由于 <code>next()</code> 方法传入参数 9，所以 <code>result</code> 的值是 9，第三行打印 11。</li>
</ol>
<p>可见 JavaScript 中的生成器通过 <code>yield value</code> 和<code>next(value)</code> 实现了值的内外双向传递。</p>
<h2 id="Generator-的实现"><a href="#Generator-的实现" class="headerlink" title="Generator 的实现"></a>Generator 的实现</h2><p>我不知道 Generator 在 JavaScript 和 Python 中的实现原理，然而用 Objective-C 确实可以模拟出来。考虑到生成器内部 <strong>运行 -&gt; 等待 -&gt; 恢复运行</strong> 的特点，信号量是最佳的实现方案。</p>
<p><code>yield</code> 实际上就是信号量的 <code>wait</code> 方法，而 <code>next()</code> 实际上就是信号量的 <code>signal</code> 方法。当然还要处理好数据的交互问题。总的来说思路还是比较清晰的。</p>
<h1 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h1><p>我们先举一个例子，看一下 Promise 的使用，每次调用函数 <code>p()</code> 都会生成一个新的 Promise 对象，内部的操作是把参数加一并返回，不妨把函数 p 想象成某个耗时操作。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">			resolve(t + <span class="number">1</span>);</div><div class="line">		&#125;, t);</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设我需要反复的、线性的执行这个耗时操作，代码将是这样的: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">p(<span class="number">0</span>).then( <span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(r);</div><div class="line">	<span class="keyword">return</span> p(r);</div><div class="line">&#125;).then( <span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(r);</div><div class="line">	<span class="keyword">return</span> p(r);</div><div class="line">&#125;).then( <span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(r);</div><div class="line">	<span class="keyword">return</span> p(r);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可见我们调用三次 <code>then</code> 方法，执行了三次加一操作，因此会有三行输出，分别是 1、2、3。</p>
<h2 id="回调改为线性"><a href="#回调改为线性" class="headerlink" title="回调改为线性"></a>回调改为线性</h2><p>文章的一开头就说了，代码总是线性执行， 遇到异步操作不会进行等待，而是直接设置好回调函数并继续向后执行。</p>
<p>实际上，如果借助于 Generator 暂停、恢复的特性，我们可以用同步的方式来写异步代码。比如我们先定义一个生成器 <code>linear()</code> 表示内部将要线性执行异步代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">linear</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> r1 = <span class="keyword">yield</span> p(<span class="number">0</span>);</div><div class="line">	<span class="built_in">console</span>.log(r1);</div><div class="line">	<span class="keyword">const</span> r2 = <span class="keyword">yield</span> p(r1);</div><div class="line">	<span class="built_in">console</span>.log(r2);</div><div class="line">	<span class="keyword">const</span> r3 = <span class="keyword">yield</span> p(r2);</div><div class="line">	<span class="built_in">console</span>.log(r3);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到 yield 的值是一个 Promise 对象，为了拿到这个对象，需要调用 <code>g.next().value</code>。因此为了让第一个输出打印来，代码是这样的: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="comment">// 其实是 Promise.then 的模式</span></div><div class="line">    <span class="comment">// 正如上一节 Generator 的例子中所述，第一个 next 会启动 Generator，并且卡在第一个 yield 上</span></div><div class="line">    <span class="comment">// 为了让程序向后执行，还需要再调用一次 next，其中的参数 0 会赋值给 r1。</span></div><div class="line">	g.next(<span class="number">0</span>).value.then()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如何模拟完整的三个 Promise 调用呢，这要求我们的代码不断向内迭代，同时用一个值保存上一次的结果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> t = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> g = linear();</div><div class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">	t = value;</div><div class="line">	g.next(t).value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">		t = value;</div><div class="line">		g.next(t).value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">			t = value;</div><div class="line">			g.next(t)</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这种写法的运行结果和之前用 <code>then</code> 语法的运行结果完全一致。</p>
<p>有的读者可能会想问，这种写法完全没有看到好处啊，反而像是回退到了最初的模式，各种嵌套不利于代码阅读和理解。</p>
<p>然而仔细观察这段代码就会发现，嵌套逻辑中更多的是架构逻辑而非业务逻辑，业务逻辑都放在 Promise 内部实现了，因此这里的复杂代码实际上是可以做精简的，它是一个结构高度一致的递归模型。</p>
<p>我们注意到 <code>g.next().value.then</code>的内部实际上是重复了外面的调用过程，如何描述这样的递归呢，有一个小技巧，只要在最外层包一个函数，然后递归执行函数就行:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归必然要有可以递归的函数，因此我们在外面包装一层函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	g.next(t).value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">		t = value;</div><div class="line">		<span class="keyword">return</span> value;</div><div class="line">	&#125;).then( <span class="function"><span class="params">result</span> =&gt;</span> recursive())</div><div class="line">&#125;</div><div class="line"></div><div class="line">recursive();</div></pre></td></tr></table></figure>
<p>然而有一个问题在于，我们必须在 <code>recursive()</code> 函数外面创建生成器 <code>g</code>，否则放在函数内部就会导致递归创建新的。因此我们可以加一个内部函数处理核心的递归问题，而外部函数处理生成器和临时变量的创建:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">generator</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> t; <span class="comment">// 临时变量，用来存储</span></div><div class="line">	<span class="keyword">var</span> g = linear();  <span class="comment">// 创建整个递归过程中唯一的生成器</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">_recursive</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		g.next(t).value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">			t = value;</div><div class="line">			<span class="keyword">return</span> value;</div><div class="line">		&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> _recursive())</div><div class="line">	&#125;</div><div class="line">	_recursive();</div><div class="line">&#125;</div><div class="line"></div><div class="line">recursive(linear);</div></pre></td></tr></table></figure>
<p>可以看到这个 <code>recursive</code> 函数完全与业务无关，对于任何生成器函数，比如说叫 g，都可以通过 <code>recursive(g)</code> 来进行调用。</p>
<p>这也就通过实际例子简单的证明了即使是异步事件也可以采用同步写法。</p>
<p>需要注明的是，这<strong>并不是</strong> async/await 语法的真正实现，这种写法的问题在于，await 外面的每一层函数都要标注为 async，然而没办法把每一个函数都转换成生成器，然后调用 <code>recursive()</code></p>
<p>感兴趣的同学可以了解一下 <a href="https://goo.gl/jlXboV" target="_blank" rel="external">babel 转换前后的代码</a>。</p>
<h2 id="“同步”-写法的设计哲学"><a href="#“同步”-写法的设计哲学" class="headerlink" title="“同步” 写法的设计哲学"></a>“同步” 写法的设计哲学</h2><p>标记了 async 的函数返回结果总是一个 Promise 对象，如果函数内部抛出了异常，就会调用 reject 方法并携带异常信息。否则就会把函数返回值作为 resolve 函数的参数调用。</p>
<p>理解了这一点以后，我们会发现 async/await 其实是<strong>异步操作的向外转移</strong>。</p>
<p>比如说 p 是一个 Promise 对象，我们可能会这样写: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> value = <span class="keyword">await</span> p;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'value = '</span> + value);</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line">test().then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</div></pre></td></tr></table></figure>
<p>我们一定程度上可以把 <code>test</code> 当做生成器来看:</p>
<ol>
<li>调用 test 方法时，首先会执行 test 内部的代码，直到遇到 await。</li>
<li>test 方法暂时退出，执行正常的逻辑，此时 test 的返回值尚不可用，但是它是一个 Promise，可以设置 then 回调。</li>
<li>await 等待的异步操作结束，test 方法返回，执行 then 回调</li>
</ol>
<p>因此我们发现异步操作并没有消失，也不可能消失，只是从 <code>await</code> 的地方转移到了外面的 <code>async</code> 函数上。如果这个函数的返回值有用，那么外部还得使用 <code>await</code> 进行等待，并且把方法标记为 <code>async</code>。</p>
<p>所以个人建议在使用 <code>await</code> 关键字的时候，首先应该判断对异步操作的依赖情况，比如以下场景就非常合适:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> sendRequest(url) &#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);  <span class="comment">// 异步请求网络</span></div><div class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> asyncStore(response);  <span class="comment">// 得到结果后异步存储数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>考虑到 <code>await</code> 会阻塞执行，如果某个 Promise 后面的代码任然需要执行(比如存储、统计、日志等)，则不建议盲目使用 <code>await</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">await</span> fetch(url);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'这里输出不了啊'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/" target="_blank" rel="external">Python yield 使用浅析</a></li>
<li><a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247484976&amp;idx=1&amp;sn=af2a8b2cabdef9f9396120ca1dd0eae5&amp;chksm=972364f2a054ede406670bf591e0723655c207994a92f7620d4392b66c467610d4be55feab9d#rd" target="_blank" rel="external">36个代码块，带你读懂异常处理的优雅演进</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25178630" target="_blank" rel="external">深入 Promise(一)——Promise 实现详解</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文的例子用 JavaScript 语法给出，希望读者至少有使用过 Promise 的经验，如果用过 async/await 则更好，对于客户端的开发者，我相信语法不是阅读的瓶颈，思维才是，因此也可以了解一下异步编程模型的演变过程。&lt;/p&gt;
&lt;h1 id=&quot;异步编程入门&quot;&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fullstack.blog/tags/JavaScript/"/>
    
      <category term="Promise" scheme="http://fullstack.blog/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>复盘微博短链接盗窃门</title>
    <link href="http://fullstack.blog/2017/02/17/%E5%A4%8D%E7%9B%98%E5%BE%AE%E5%8D%9A%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%9B%97%E7%AA%83%E9%97%A8/"/>
    <id>http://fullstack.blog/2017/02/17/复盘微博短链接盗窃门/</id>
    <published>2017-02-17T14:06:10.000Z</published>
    <updated>2017-02-17T14:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这不是意外，不是 bug，是蓄谋已久的阴谋! 不知道阅读完以后，你会不会和我一样心里发寒</strong></p>
<h1 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h1><p>前两天传出了新浪微博利用短链接恶意盗取用户收益的事件，可能很多吃瓜群众还不是特别明白是咋回事。这里我简单复盘一下，顺便聊聊个人的见解。</p>
<p>事情最初由 @im61 的这张图片引起:</p>
<p><img src="http://images.bestswifter.com/1487336629.png" alt=""></p>
<h1 id="利益分析"><a href="#利益分析" class="headerlink" title="利益分析"></a>利益分析</h1><p>首先要知道苹果的 iTunes 联盟，这个可以算是苹果官方的推广平台，具体介绍<a href="https://itunes.phgconsole.performancehorizon.com/login/itunes/zh_cn" target="_blank" rel="external">看这里</a>，我没有用过，不过概括来说这个联盟就是一个平台，推广者帮忙推广 App，一旦有用户产生下载行为，推广者就可以获得收益。</p>
<p>这个联盟显然是一个三方平台，对推广者和应用开发者来说是双赢的局面，前者收获推广费用，后者获得下载流量，从而获得盈利。</p>
<p>为了标记某一次下载背后的推广者是谁(这样才好分成)，苹果为每一个推广者提供了推广 ID(其实还有活动码，不过不是重点，所以略过)，比如说某个应用的下载地址可能是:</p>
<blockquote>
<p><a href="https://itunes.apple.com/bestswifter" target="_blank" rel="external">https://itunes.apple.com/bestswifter</a></p>
</blockquote>
<p>那么带有推广码的下载地址就是:</p>
<blockquote>
<p><a href="https://itunes.apple.com/bestswifter?at=1001|sTF" target="_blank" rel="external">https://itunes.apple.com/bestswifter?at=1001|sTF</a></p>
</blockquote>
<p>可以看到 HTTP 请求多了一个参数，参数的值 <code>1001|sTF</code> 就是 @im61 同学的推广码， 一旦用户点击了带推广码的地址，@im61 同学就会产生收益。</p>
<h1 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h1><p>由于 App 的下载地址本来就很长，再加上推广码和活动 ID，非常不利于阅读，因此微博提供了短链接生成器，比如通过微博的短链接生成器，我的长连接 <strong><a href="https://itunes.apple.com/bestswifter?at=1001|sTF" target="_blank" rel="external">https://itunes.apple.com/bestswifter?at=1001|sTF</a></strong> 会被转换成 <strong><a href="http://t.cn/RJ8HDRC" target="_blank" rel="external">http://t.cn/RJ8HDRC</a></strong>:</p>
<p><img src="http://images.bestswifter.com/1487337349.png" alt=""></p>
<p>当你打开短链接的时候，实际上会经过一次 302 跳转，跳到原地址(也就是长连接的地址)。这个技术相当容易实现，因为理论上来说只要用一个字典来存储， 值是长连接，键是短链接(比如最简单的生成方法就是哈希一下)。</p>
<p>这样当你访问 <code>http://t.cn/RJ8HDRC</code> 这个网址时，服务器会拿到 <code>RJ8HDRC</code> 这个键，然后找到对应的值，也就是原始的 iTunes 长连接，再动态拼凑出一个 302 请求即可。302 请求表示页面临时被移动，根据 HTTP 规范，浏览器会重新请求新的临时地址。</p>
<p>我们可以验证一下:</p>
<p><img src="http://images.bestswifter.com/1487337696.png" alt=""></p>
<h1 id="新浪微博是如何作恶的"><a href="#新浪微博是如何作恶的" class="headerlink" title="新浪微博是如何作恶的"></a>新浪微博是如何作恶的</h1><p>首先我们看到红色划线部分，有两个 at 参数，那么服务器以哪个为准呢，答案是不一定。HTTP 协议中并没有规定当 GET 方法的 Query 中出现重复的 key 怎么办，所以通常来说有三种解决方法:</p>
<ol>
<li>以前面的为准，比如 <code>&amp;at=1&amp;at=2</code> 会被服务器当做 <strong><code>&amp;at=1</code></strong> 处理</li>
<li>以后面的为准，比如 <code>&amp;at=1&amp;at=2</code> 会被服务器当做 <strong><code>&amp;at=2</code></strong> 处理</li>
<li>以两者的拼接结果为准，比如 <code>&amp;at=1&amp;at=2</code> 会被服务器当做 <strong><code>&amp;at=[1，2]</code></strong> 处理</li>
</ol>
<p>不同的 Web 服务器实现方法并不一样，比如 PHP 4.4 以后采用的是上述第二种方案。所以我们观察截图可以发现，</p>
<p><strong>微博在原先的 at 字段后面新增了一个重复字段，填上了自己的推广码，一旦用户访问短链接，它返回的 302 重定向实际指向了微博自己的推广链接。</strong></p>
<p>这也证明不管苹果使用的是哪种 Web 服务器，必然都是使用了第二种处理策略。</p>
<p>稍微一动脑子就可以想明白四件事情:</p>
<ol>
<li>微博专门为窃取利益做了调试，它必须搞明白苹果 Web 服务器的处理逻辑。如果采用的是第一种策略，微博就不是在原先的 at 字段后面新增，而是在前面新增。</li>
<li>只要短链接控制权在微博手上，它就可以随意做出修改，当然如果苹果采用了第三种策略，微博是无能为力的(苹果表示这个锅我不背)。</li>
<li>显然并不是所有的链接都会被加上这样的参数，否则有相当多的地址都无法打开，比如我的博客 <code>https://bestswifter.com</code> 生成的短链接再解析回来依然正常。可见微博专门对短链接格式做了判断，如果是以 iTunes 开头才会做手脚。</li>
<li>这也是我觉得最可怕的一点，微博可以针对 iTunes 做专门处理，自然也可以针对其他推广链接做类似处理，至于微博偷走了多少钱，我们不得而知。</li>
</ol>
<p>更让人气愤但是，@im61 同学的微博在 2017 年 2 月 16 日中午一点钟发出，而我写作本文的时间是 17 日晚上 10 点，接近一天半的时间内微博找出各种理由，但就是没有修改的意图。根据我的经验来看，这种策略的添加和删除都是极为容易的，开发者一定提供了良好的接口。</p>
<p>所以我猜测微博的管理层觉得事情还不够大，每拖延一分一秒，又是一大笔收入，年底的财报和股价会更好看。</p>
<p>我没有办法证明时间的准确性，不过希望看到本文的读者还有机会亲自体验一下微博做的恶。</p>
<h1 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h1><p>对于微博这种要钱不要脸的行为，如何防范呢，我想大概有两种方法。</p>
<p>第一种方法是利用第三方短链接服务，即先将自己的原始地址转换成安全的短链接，然后再将这个短链接转换成微博的短链接。这是原贴评论中有人提出的方案，我不知道为什么非要使用微博短链接(刚刚测了一下，使用别的短链接生成器似乎也可以)，这里姑且认为是有什么限制吧。</p>
<p>这种方法是一种临时方法，并不保险，因为微博完全可以做一个递归判断，首先检查你的链接访问以后是不是 302，如果是 302 则抓取重定向的地址，直到找到 iTunes 为止。幸好暂时微博还没有这么做，不过为了钱，相信我，微博什么都做得出来。他们可以<a href="http://weibo.com/ttarticle/p/show?id=2309404074275521878291#_0" target="_blank" rel="external">不让你提现，帮你自动发广告微博，乱插时间线</a>。</p>
<h2 id="自建服务器"><a href="#自建服务器" class="headerlink" title="自建服务器"></a>自建服务器</h2><p>最稳妥的方法还是使用自己的服务器，不过评论区中的 HTTPS 加密似乎用处不大。因为 HTTPS 加密只是请求过程加密，而你在发起请求时，必然走的是 GET 方法打开一个 URL，所以自己的推广码必然是明文放在请求头部，比如</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP GET <span class="string">https:</span><span class="comment">//bestswifter.com/promotion=我的推广码</span></div></pre></td></tr></table></figure>
<p>然后我在自己的服务器上返回一个 302 重定向，带上推广码，重定向到 iTunes 上。</p>
<p>在我看来这种做法已经足够安全，因为微博没办法识别自己的 URL 特征，前文说过它只是依赖于 iTunes 开头的链接的识别。当我的域名和 query 键名都被混淆后，微博不可能再对我请求做任何修改，如果还不放心，还可以在服务器上对请求参数自行校验。</p>
<p>总的来说，控制权在自己手上才是最安全。</p>
<h1 id="微博做了哪些恶"><a href="#微博做了哪些恶" class="headerlink" title="微博做了哪些恶"></a>微博做了哪些恶</h1><p>对于微博这样的中间平台来说，它本应该提供更好的安全保护服务，保护用户的合法利益不受侵犯。比如我们目前在做的广告和计费服务，客户端看到的并不是广告的真实地址， 也不会直接向服务器发送扣费请求。客户端能拿到的只是一个加了密的地址，在请求服务器时，一方面服务器对参数解密，进行扣费，另一方面返回 302，重定向到真正的广告地址。</p>
<p>而微博做的确实煞费苦心的调试广告平台存在的 bug，利用自身优势伪造请求数据(类似于 SQL 注入和 XSS 攻击)，并针对不同目标平台做出区分，“优化” 自身收益。当恶行被曝光后，选择是找借口、拖时间而非及时承认错误，抓紧一分一秒从用户手上抢钱。</p>
<p>我想，微博欠无数像 @im61 这样的用户一个道歉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这不是意外，不是 bug，是蓄谋已久的阴谋! 不知道阅读完以后，你会不会和我一样心里发寒&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;事件背景&quot;&gt;&lt;a href=&quot;#事件背景&quot; class=&quot;headerlink&quot; title=&quot;事件背景&quot;&gt;&lt;/a&gt;事件背景&lt;
    
    </summary>
    
    
      <category term="HTML" scheme="http://fullstack.blog/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 模块化简析</title>
    <link href="http://fullstack.blog/2017/01/25/JavaScript%20%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E8%BF%B0/"/>
    <id>http://fullstack.blog/2017/01/25/JavaScript 模块化简述/</id>
    <published>2017-01-25T03:58:44.000Z</published>
    <updated>2017-01-25T04:02:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于模块化，最直接的表现就是我们写的 <code>require</code> 和 <code>import</code> 关键字，如果查阅相关资料，就一定会遇到 <code>CommonJS</code> 、<code>CMD</code> <code>AMD</code> 这些名词，以及 <code>RequireJS</code>、<code>SeaJS</code> 等陌生框架。比如 <a href="http://seajs.org/docs/" target="_blank" rel="external">SeaJS 的官网</a> 这样描述自己: “简单友好的模块定义规范，Sea.js 遵循 CMD 规范。自然直观的代码组织方式，依赖的自动加载……”</p>
<p>作为前端新手，我表示实在是一脸懵逼，理解不能。按照我一贯的风格，介绍一个东西之前总得解释一下为什么需要这个东西。</p>
<h1 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h1><p>做客户端的同学对 OC 的 <code>#import &quot;classname&quot;</code>、Swift 的 Module 以及文件修饰符 和 Java 的 <code>import package+class</code> 模式应该都不陌生。我们习惯了引用一个文件就是引用一个类的模式。然而在 JavaScript 这种动态语言中，事情又有一些变化，举个例子说明:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"hello"</span>&gt;</span> Hello Wrold <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"onPress()"</span> <span class="attr">value</span>=<span class="string">"Click me"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    p.innerHTML = <span class="string">'Hello bestswifter'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HTML 中的 <code>&lt;script&gt;</code> 标签可以理解为 import，这样按钮的 <code>onclick</code> 事件就可以调用定义在 <code>index.js</code> 中的 <code>onPress</code> 函数了。</p>
<p>假设随着项目的发展，我们发现点击后的文字需要动态生成，并且由别的 JS 文件生成，那么简单的 <code>index.js</code> 就无法胜任了。我们假设生成的内容定义在 <code>math.js</code> 文件中:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照客户端的思维，此时的 <code>index.js</code> 文件应该这样写:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="keyword">import</span> <span class="string">"math.js"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    p.innerHTML = add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很不幸，JavaScript 并不支持 import 这种写法，也就是说在一个 JS 文件中根本无法引用别的 JS 文件中的方法。正确的解决方案是在 <code>index.js</code> 中直接调用 <code>add</code> 方法，同时在 <code>index.html</code> 中引用 <code>math.js</code>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"math.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"hello"</span>&gt;</span> Hello Wrold <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"onPress()"</span> <span class="attr">value</span>=<span class="string">"Click me"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    p.innerHTML = add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到这种写法并不优雅， <code>index.js</code> 对别的 JS 文件中的内容并没有控制权，能否调用到 <code>add</code> 方法完全取决于使用自己的 HTML 文件有没有正确引用别的 JS 文件。</p>
<h1 id="初步模块化"><a href="#初步模块化" class="headerlink" title="初步模块化"></a>初步模块化</h1><p>刚刚所说的痛点其实可以分为两种:</p>
<ol>
<li>index.js 无法 import，依赖于 HTML 的引用</li>
<li>index.js 中无法对 add 方法的来源做区分，缺少命名空间的概念</li>
</ol>
<p>第一个问题留在后面解答，我们先着手解决第二个问题，比如先把函数放到一个对象中，这样我们可以暴露一个对象，让使用者调用这个对象的多个方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    p.innerHTML = math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//math.js</span></div><div class="line"><span class="keyword">var</span> math = &#123;</div><div class="line">    <span class="attr">base</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> a + b + base;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到在 <code>index.js</code> 中已经可以指定一个简易版的命名空间了(也就是 math)。但目前还有一个小问题，比如 base 这个属性会被暴露给外界，也可以被修改。所以更好的方式是将 <code>math</code> 定义在一个闭包里，从而隐藏内部属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="keyword">var</span> math = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> base = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a + b + base;</div><div class="line">        &#125;,</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>到目前为止，我们实现了模块的定义和使用。不过模块化的一大精髓在于命名空间，也就是说我们希望自己的 <code>math</code> 模块不是全局的，而是按需导入，这样一来，即使多个文件暴露同名对象也不会出问题。就像 node.js 中那样，需要暴露的模块定义自己的 export 内容，然后调用方使用 require 方法。</p>
<p>其实可以简单模拟一下 node.js 的工作方式，通过增加一个中间层来解决: 首先定义一个全局变量:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// global.js</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</div><div class="line">    <span class="attr">exports</span>: &#123;&#125;, <span class="comment">// 用来存储所有暴露的内容</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在 <code>math.js</code> 中暴露对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> base = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a + b + base;</div><div class="line">        &#125;,</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports.math = math;</div></pre></td></tr></table></figure>
<p>使用者 <code>index.js</code> 现在应该是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = <span class="built_in">module</span>.exports.math;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    <span class="comment">// math</span></div><div class="line">    p.innerHTML = math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="现有模块化方案"><a href="#现有模块化方案" class="headerlink" title="现有模块化方案"></a>现有模块化方案</h1><p>上述简单的模块化方式有一些小问题。首先，<code>index.js</code> 必须严格依赖于 <code>math.js</code> 执行，因为只有 <code>math.js</code> 执行完才会向全局的 <code>module.export</code> 中注册自己。这就要求开发者必须手动管理 js 文件的加载顺序。随着项目越来越大，依赖的维护会变得越来越复杂。</p>
<p>其次，由于加载 JS 文件时，浏览器会停止渲染网页，因此我们还需要 JS 文件的异步按需加载。</p>
<p>最后一个问题是，之前给出的简化版模块化方案并没有解决模块的命名空间，相同的导出依旧会替换掉之前的内容，而解决方案则是维护一个 “文件路径 &lt;–&gt; 导出内容” 的表，并且根据文件路径加载。</p>
<p>基于上述需求，市场上出现了很多套模块化方案。为啥会有多套标准呢，实际上还是由前端的特性导致的。由于缺乏一个统一的标准，所以很多情况下大家做事的时候都是靠约定，就比如上述的 export 和 require。如果代码的提供者把导出内容存储在 <code>module.exports</code> 里，而使用者读取的是 <code>module.export</code>，那自然是徒劳的。不仅如此，各个规范的实现方式、使用场景也不尽相同。</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>比较知名的规范有 CommonJS、AMD 和 CMD。而知名框架 Node.js、RequireJS 和 Seajs 分别实现了上述规范。</p>
<p>最早的规范是 CommonJS，Node.js 使用了这一规范。这一规范和我们之前的做法比较类似，是同步加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范无法直接在浏览器中使用。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>浏览器端著名的模块管理工具 Require.js 的做法是异步加载，通过 Webworker 的 <code>importScripts(url);</code> 函数加载 JS 脚本，然后执行当初注册的回调。Require.js 的写法是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'myModule1'</span>, <span class="string">'myModule2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>)</span>&#123;</div><div class="line">    <span class="comment">// 主回调逻辑</span></div><div class="line">    m1.printName();</div><div class="line">    m2.printName();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>由于这两个模块是异步下载，因此哪个模块先被下载、执行并不确定，但可以肯定的是主回调一定在所有依赖都被加载完成后才执行。</p>
<p>Require.js 的这种写法也被称为前置加载，在写主逻辑之前必须指定所有的依赖，同时这些依赖也会立刻被异步加载。</p>
<p>由 Require.js 引申出来的规范被称为 AMD(Asynchronous Module Definition)。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>另一种优秀的模块管理工具是 Sea.js，它的写法是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'foo'</span>); <span class="comment">// 同步</span></div><div class="line">    foo.add(<span class="number">1</span>, <span class="number">2</span>); </div><div class="line">    ...</div><div class="line">    require.async(<span class="string">'math'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123; <span class="comment">// 异步</span></div><div class="line">        math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Sea.js 也被称为就近加载，从它的写法上可以很明显的看到和 Require.js 的不同。我们可以在需要用到依赖的时候才申明。</p>
<p>Sea.js 遇到依赖后只会去下载 JS 文件，并不会执行，而是等到所有被依赖的 JS 脚本都下载完以后，才从头开始执行主逻辑。因此被依赖模块的执行顺序和书写顺序完全一致。</p>
<p>由 Sea.js 引申出来的规范被称为 CMD(Common Module Definition)。</p>
<h1 id="ES-6-模块化"><a href="#ES-6-模块化" class="headerlink" title="ES 6 模块化"></a>ES 6 模块化</h1><p>在 ES6 中，我们使用 <code>export</code> 关键字来导出模块，使用 <code>import</code> 关键字引用模块。需要说明的是，ES 6 的这套标准和目前的标准没有直接关系，目前也很少有 JS 引擎能直接支持。因此 Babel 的做法实际上是将不被支持的 <code>import</code> 翻译成目前已被支持的 <code>require</code>。</p>
<p>尽管目前使用 <code>import</code> 和 <code>require</code> 的区别不大(本质上是一回事)，但依然强烈推荐使用 <code>import</code> 关键字，因为一旦 JS 引擎能够解析 ES 6 的 <code>import</code> 关键字，整个实现方式就会和目前发生比较大的变化。如果目前就开始使用 <code>import</code> 关键字，将来代码的改动会非常小。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>以上内容大部分都不是我的思考结果，我只是对已有的文章做了一下实际操作和归纳总结，感谢各位前辈的优秀文章:</p>
<ol>
<li><a href="http://stackoverflow.com/questions/3244361/can-i-access-variables-from-another-file" target="_blank" rel="external">Can I access variables from another file?</a></li>
<li><a href="https://segmentfault.com/a/1190000000492678" target="_blank" rel="external">浅谈 JavaScript 模块化编程</a></li>
<li><a href="http://www.cnblogs.com/dolphinX/p/4381855.html" target="_blank" rel="external">前端模块化</a></li>
<li><a href="https://segmentfault.com/a/1190000000733959#articleHeader6" target="_blank" rel="external">详解JavaScript模块化开发</a></li>
<li><a href="http://www.html-js.com/article/AngularJs-requireJS-the-realization-principle-of-1" target="_blank" rel="external">requireJS实现原理研究</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">Javascript模块化编程（一）：模块的写法</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="external">Javascript模块化编程（二）：AMD规范</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html" target="_blank" rel="external">浏览器加载 CommonJS 模块的原理与实现</a></li>
<li><a href="http://imweb.io/topic/582293894067ce9726778be9" target="_blank" rel="external">Node中没搞明白require和import，你会被坑的很惨</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于模块化，最直接的表现就是我们写的 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 关键字，如果查阅
    
    </summary>
    
    
      <category term="前端" scheme="http://fullstack.blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://fullstack.blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>我的 2016 年总结</title>
    <link href="http://fullstack.blog/2016/12/31/%E6%88%91%E7%9A%84-2016-%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://fullstack.blog/2016/12/31/我的-2016-年总结/</id>
    <published>2016-12-31T15:47:39.000Z</published>
    <updated>2016-12-31T12:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>时光飞逝，一转眼已经是一年过去了， 去年的今天我写下了第一篇年度总结：<a href="http://www.jianshu.com/p/fe529a7e83a0" target="_blank" rel="external">一个普通iOS开发者的2015大总结</a>。在写作那篇文章之前，我觉得一年前的自己完全是一个傻逼；今天重读一遍以后，我感觉一年前的自己也非常傻逼。在写下这一年总结的同时，我也希望明年的自己在回顾这篇文章的时候，可以发出不屑的鄙视。</p>
<p>实际上我认为:</p>
<blockquote>
<p>刚开始学习的前五年是发展最快的五年，每一年都应该感觉到自己在过去的一年中发生了天翻地覆的变化。</p>
</blockquote>
<p>本文既然是总结， 自然是充满了大量的主观看法。如果读者不认可其中的某些观点，大可呵呵一笑，抛之脑后，切勿较真，做无意义的争论。</p>
<h1 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h1><p>我从元旦后就开始着手准备春招。首先翻译完了 <a href="http://www.jianshu.com/p/18744b078508" target="_blank" rel="external">Advanced Swift</a>(盗版可耻)，这是自己第一次完整的阅读完一本英语书籍，学到了非常多的知识，有英语方面的，也有 Swift 方面的，随后自己尝试着用 Swift 开发了一个小 app。虽然后续由于工作原因没有能继续接触 Swift，不过它的优雅、简洁还是深深的吸引了我。希望 Swift 4.0 发布后能够解决 ABI 稳定问题。</p>
<p>如果 Xcode 对 Swift 的支持能更友好，业内再提出成熟的动态化方案，我相信 Swift 会有更光明的未来和使用场景。</p>
<h2 id="Swift-与后端开发"><a href="#Swift-与后端开发" class="headerlink" title="Swift 与后端开发"></a>Swift 与后端开发</h2><p>随着 Swift 的愈发成熟，业内出现了很多比较成熟的后端开发框架， 比如 <a href="http://perfect.org/" target="_blank" rel="external">perfect</a>、<a href="https://vapor.codes/" target="_blank" rel="external">vapor</a> 等。然而我本人并不看好这一领域，主要是从编程语言和程序员两个角度出发。</p>
<p>理论上来说，任何可以调用 socket 接口处理网络请求的语言都可以用来做后端开发，然而对于 Swift 来说，除了处理网络请求以外，一个优秀的 API 也至关重要。不管是 HTTP 协议的解析，还是字符串、栈、时间等常用数据结构的操作，都不方便由做业务的程序员去手动解析。</p>
<p>框架的使用者应该关注业务开发，而不是通用业务的处理。比较遗憾的是，Swift 目前在这一方面做的还不够好，很多重要的操作缺乏语言层面的支持，导致开发者造轮子的成本过高。不过 Swift 已经成立了官方小组，致力于解决这一问题。</p>
<p>考虑到 Swift 还不是个非常成熟的语言，目前还在快速迭代。相比于语言本身，我认为人的问题才是阻碍 Swift 在服务端发力的最大原因。不管是现有哪种用来进行后端开发的语言，都有它本身的卖点。比如 Java 的高效(运行时效率)、稳定、全面，或者 PHP、Ruby 的语法简洁，易上手，还是 GO 的高并发，亦或是 Node.js 的全栈，都能在某个特定场景下派上用场。</p>
<p>目前的 Swift 似乎还没有找到属于自己的舞台，由于绝大多数开发者都是 iOS 开发者，他们并不适合转向服务端开发，这就意味着 Swift 能写 iOS 毫无吸引力(参考一下 JS 能做哪些事)。而对于具有服务的开发经验的开发者来说，Swift 又没有吸引他们切换过去的理由。</p>
<h1 id="准备春招"><a href="#准备春招" class="headerlink" title="准备春招"></a>准备春招</h1><p>一不小心就扯远了， 话题回到总结上来。完成了 Swift 学习的收尾工作后，我的精力主要放在春招上。由于大二下学期积累了三个月的实习经验，这一阶段的目的主要是夯实基础。因此重点读了两本书，《图解 TCP/IP》(<a href="http://www.jianshu.com/notebooks/3276500/latest" target="_blank" rel="external">总结</a>)、《剑指 Offer》。</p>
<h2 id="图解-TCP-IP"><a href="#图解-TCP-IP" class="headerlink" title="图解 TCP/IP"></a>图解 TCP/IP</h2><p>这本书主要是讲解了 TCP/IP 四层协议栈(或者分得更细点就是七层)，通过一些插图和实际例子来解释枯燥的概念。我认为这是一本不可多得的好书，尤其适合新手入门。不过，如果想精通网络层，还是建议买 《TCP/IP 详解》和 《HTTP 权威指南》或者直接查阅 RFC 协议。</p>
<p>不过在准备面试，或者新手入门时，我觉得非常有必要通过一本简短的书籍来形成大致的知识框架和，这样后续才能有针对性的学习总结，对自己的知识框架进行各种修修补补。</p>
<h2 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h2><p>这本书相当应试，不过也必须承认它概括了绝大多数常见的算法面试题。如果我们把面试看做是企业对应聘者的能力筛选和鉴定而不是刁难，那么从一定角度来说，也可以证明这本书涵盖了绝大多数常见的场景和算法。</p>
<p>如果不想只是纸上谈兵，还可以去 <a href="https://leetcode.com/problemset/algorithms/" target="_blank" rel="external">Leetcode</a> 上找找书中问题对应的题目，参考全世界大牛的精妙解法也会受益匪浅。</p>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><p>作为一名 iOS 开发者，iOS 开发是我的本业，除了准备计算机基础知识外，我也学习了很多 iOS 开发的知识。以上的详细内容都总结在 《<a href="http://www.jianshu.com/p/ee15c1cf9c16" target="_blank" rel="external">让 BAT 的 Offer 不再难拿</a>》，就不赘述了。</p>
<h1 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h1><p>春招顺利的拿到了百度贴吧的 offer，入职以后受益匪浅。在善品、权叔等老司机的带领下，我有一种乡下人进城的兴奋感，感觉自己的成长速度非常快。</p>
<h2 id="MVC-与-UITableview"><a href="#MVC-与-UITableview" class="headerlink" title="MVC 与 UITableview"></a>MVC 与 UITableview</h2><p><code>UITableview</code> 是 iOS 开发中最常见的 UI 控件之一，但是想写好一个 <code>UITableview</code>，做到封装、解耦，并与网络请求良好的结合起来并不容易。我花了一定时间学习了贴吧以前的框架，对其做了一些简化和整理，总结在这里: <a href="http://www.jianshu.com/p/504c61a9dc82" target="_blank" rel="external">如何写好一个UITableView</a>。框架没有最优与全能，适合团队业务的就是最好的，所以这套框架主要是为了贴吧业务打造，但也有自己的不足，读者切不可照搬全抄。</p>
<h2 id="高效使用-Mac"><a href="#高效使用-Mac" class="headerlink" title="高效使用 Mac"></a>高效使用 Mac</h2><p>我比较看重开发效率，因为我认为开发者应该把宝贵的时间花费在工作本身，而不是与之无关的杂事上。并不耗时的高频操作和比较耗时的中频操作都应该使用快捷键或自动化工具对其进行简化，不过也切忌矫枉过正。对非常低频的操作进行自动化或者仅仅是为了装逼，往往会浪费大量不必要的时间，反而适得其反。</p>
<p>我总结了<a href="http://www.jianshu.com/p/2b072b206c90" target="_blank" rel="external">一篇文章</a> 并做了<a href="http://m.quzhiboapp.com/#!/intro/193" target="_blank" rel="external">一次直播</a>，主要涉及全局快捷键、Xcode、Vim、Chrome、Vimium、Git、Zsh、Alfred、Zsh、Emacs 等. 强烈建议对此还不了解的读者收看直播回放。</p>
<h1 id="iOS-深入"><a href="#iOS-深入" class="headerlink" title="iOS 深入"></a>iOS 深入</h1><p>在工作之余，我对 iOS 领域的一些常用知识做了深入学习。</p>
<h2 id="GCD-与多线程"><a href="#GCD-与多线程" class="headerlink" title="GCD 与多线程"></a>GCD 与多线程</h2><p>虽然去年就复习过类似的话题，但仅仅是停留在总结整理的层面，说白了就是把所有 API 熟悉了一遍。这次学习时，我阅读了 GCD 的源码，从而从更深层次理解了 GCD 的实现原理，总结了一篇文章: <a href="http://www.jianshu.com/p/06a18323d9d2" target="_blank" rel="external">深入理解 GCD</a>。</p>
<h2 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h2><p>最初接触 runloop 是听了孙源大神的分享，随着学习的深入，发现还是有必要对 Runloop 进行深入的理解。不过 Runloop 虽然重要，但实际使用中接触得并不太多，除了常见的 NSTimer 触发问题外，也就是性能检测时会与之打交道。所以它源码阅读的必要性并不是太高，我觉得只要对 Runloop 的基本概念和工作原理有所涉猎即可。遇到实际问题时可以查阅 ibireme 的 <a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>。</p>
<p>我写了一篇: <a href="http://www.jianshu.com/p/10121d699c32" target="_blank" rel="external">深入研究 Runloop 与线程保活</a> 作为自己的学习总结。</p>
<h2 id="线程调用栈"><a href="#线程调用栈" class="headerlink" title="线程调用栈"></a>线程调用栈</h2><p>上一节谈到了利用 runloop 检测主线程的卡顿。为了找到性能瓶颈，也就是优化点，我们需要在卡顿发生时得到实时的线程调用栈。这就意味着一切依赖于线程层面的操作都会破坏原来线程的调用栈。在尝试使用信号无果后，最终我选择了参考第三方开源框架，直接利用 C 语言解析函数调用栈。具体总结参考: <a href="http://www.jianshu.com/p/7e4c7b94ca36" target="_blank" rel="external">获取任意线程调用栈的那些事</a>。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>iOS 中有很多锁，从最底层的互斥锁、信号量到顶层的 <code>@synchronized</code>，应有尽有。虽然我实际使用经验并不多，但还是研究了一下他们的实现原理和性能优劣: <a href="http://www.jianshu.com/p/8781ff49e05b" target="_blank" rel="external">深入理解 iOS 开发中的锁</a>。随着对多线程在理论和实践上的进一步接触，我相信还会有更具深度的总结面世。</p>
<h2 id="Xcode-项目配置"><a href="#Xcode-项目配置" class="headerlink" title="Xcode 项目配置"></a>Xcode 项目配置</h2><p>出于对 Cocoapods 工作原理的兴趣，我前段时间手动模拟了它的工作过程(自动化是通过 ruby 脚本完成的，相对而言重要性低很多)。在这一过程中，更重要的是对编译、链接、Xcode 工程配置的理解。由于时间原因，目前还没有形成总结性文档。</p>
<h1 id="全栈"><a href="#全栈" class="headerlink" title="全栈"></a>全栈</h1><p>相比于 iOS 方面的钻研，2016 年最让我感到激动和收益满满的是横向的拓展。关于为什么会选择横向发展路线，在我的 <a href="http://fullstack.blog/2016/11/18/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/">新的开始</a> 一文中已经有了详细的阐述。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是常见的数据结构，但是很多人对他的掌握都非常浅显。曾经问过很多人一个很简单的问题:“为什么很多哈希表的实现中，数组的长度都是 2 的整数次幂？”。根据我的观察，能答出这个问题的人寥寥无几，有很多看上去很正确的废话，其实恰恰说明了大多数人多哈希表的理解还不够深入。</p>
<p>除此以外，不同的语言和框架(OC、Java、Redis、一致性哈希) 对哈希表的实现都各不相同，他们的取舍恰恰说明不同场景下我们关注的指标并不一致，必须舍弃一些无关紧要的功能点，来换取主要功能的性能的大幅度提高。具体对比请参考: <a href="http://www.jianshu.com/p/138ccbc75803" target="_blank" rel="external">深入理解哈希表</a>。</p>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>市面上有很多介绍 Node.js  的优秀文章和书籍，作为一个不懂 Node.js 的小白，其实我只关系以下几个问题:</p>
<ol>
<li>为什么要从现有的后端开发框架切换到 Node.js？</li>
<li>Node.js 是银弹么，还是有特别适合自己的使用场景？</li>
<li>Node.js 的事件循环是如何工作的？有什么好处？</li>
<li>Node.js 是异步单线程的， 那么如何最大程度的利用多核 CPU 的所有性能？</li>
</ol>
<p>作为上述问题的回答，我总结了 <a href="http://www.jianshu.com/p/59e59acde382" target="_blank" rel="external">为什么要用 Node.js</a>。</p>
<h2 id="前后端分离与前端开发流程"><a href="#前后端分离与前端开发流程" class="headerlink" title="前后端分离与前端开发流程"></a>前后端分离与前端开发流程</h2><p>在学习 Node.js 的过程中，我接触到了一个新名词:前后端分离。对于客户端开发者来说，前后端分离是一件天经地义的事情。前端界面是由编译后的代码生成的，相对来说比较固定。前后端的主要交流方式是 JSON/protobuf 等数据交换格式。</p>
<p>然而对于前端开发者来说，事情远远不止这么简单。由于前端的 UI 样式完全由 Server 下发，所以很容易就产生了前后端业务和代码的耦合。所以前后端分离说的就是前端开发和后端开发如何进行解耦和数据交互，详见 <a href="http://www.jianshu.com/p/36a3c79cd18f" target="_blank" rel="external">移动端开发者眼中的前端开发流程变迁与前后端分离</a>。</p>
<h2 id="利用-JS-等脚本语言实现客户端热更新"><a href="#利用-JS-等脚本语言实现客户端热更新" class="headerlink" title="利用 JS 等脚本语言实现客户端热更新"></a>利用 JS 等脚本语言实现客户端热更新</h2><p>不管是 JSPatch 还是 React Native，它们都能做到客户端的热更新，甚至无需通过 AppStore 即可发一个新版本。它们之所以能够做到客户端热更新，主要是依赖了客户端对 JavaScript 的支持以及 iOS 自身基于 runtime 的元编程技术。首先，利用 JSON 传递信息的区别在于它仅有描述信息，却无法携带逻辑信息。</p>
<p>通过官方认可的 JavaScriptCore 框架，我们可以运行一段 JavaScript 代码并获取运行结果。通过对运行结果的解析，我们可以利用 runtime 动态的调用本地预定义好的方法，从而实现了动态化。</p>
<p>React Native 的本质是一个 Hybrid 桥。它与 React 具有相同的 API，为了实现相同的效果，客户端会调用本地的方法(比如 <code>addSubview</code> 等)。详细请参考: <a href="http://www.jianshu.com/p/978c4bd3a759" target="_blank" rel="external">React Native 从入门到原理</a>。</p>
<h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><p>一般来说我们认为脚本语言就是没有编译器的、由解释器动态解释的语言。它通常具有弱类型、格式简单、开发效率高等优点，但是作为代价，用脚本语言来开发大型项目会遇到诸多问题。比如性能、调试等等，毕竟它们原本只是用来快速完成某个小的需求。</p>
<p>我最先接触的是 python，我使用 python 编写了 alfred 的一个 workflow，后来在 leader 的带领下实现了一个可以 hook 请求和返回结果的 http 代理服务器。有了实战的机会，也就成功脱离了 hello world 的水平了。</p>
<p>同时我也简单接触了 Ruby。光从脚本语言的角度来看，它和 Python 的作用相仿。不过很多领域特定语言(DSL) 都选择了 Ruby 来实现， 比如我们常用的 cocoapods 中的 Podfile，如果不说，可能只有少数人能意识到这其实是一段标准的 Ruby 代码。</p>
<p>之所以选择用 Ruby 来实现，是因为它的语法可读性更好，看上去就像一段普通的描述性文字。详细的分析可以参考: <a href="http://www.jianshu.com/p/2434e62158d1" target="_blank" rel="external">白话 Ruby 与 DSL 以及在 iOS 开发中的运用</a>。</p>
<p>严格意义上来说，Shell 脚本才是脚本语言的鼻祖，它提供了非常多常用的工具，比如 <code>awk</code> 和 <code>sed</code> 两大文本处理利器。如果需要对文字、文件目录做简单的逻辑操作，应该优先使用 Shell 而不是其他脚本语言。</p>
<p>不同的脚本语言往往是为了解决不同领域的问题而诞生的(虽然它们也可以解决其他问题)，遇到问题的时候应该选择最合适、优雅的解决方案，而不是总想着复用当前技术栈。俗话说:“如果你只有锤头，那看什么都是钉子”。</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>Swift 诞生后就一直宣传自己面向接口编程的特性，然而在我看来它不过是一种多继承的实现方案。且不谈继承的缺点以及在它和组合之间如何选择，光是多继承，就有很多种实现。比如 C++、Python、Java、Ruby 都有各自的实现。其中有优雅的，也有相对来说比较暴力直接的。</p>
<p>我个人更喜欢 Java 对多继承的实现，与之相比，Swift 的面向接口编程还有一些可以提高的地方。详细可以参考: <a href="http://www.jianshu.com/p/fc105512bf40" target="_blank" rel="external">从 Swift 的面向协议编程说开去</a></p>
<h2 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h2><p>从 12 月份开始，由于安卓同事返校上课，我有机会开始接触安卓开发。目前还停留在小白阶段，只能根据前人的代码抄抄改改。安卓的学习主要还是 API 的积累和 Java 语言的学习，希望能在明年总结出更多关于安卓的优秀文章。</p>
<h1 id="我的-2016"><a href="#我的-2016" class="headerlink" title="我的 2016"></a>我的 2016</h1><p>对于把好好的年终总结写成了博客摘要我是很不满意的，如果用一个词来总结我的 2016 年，我想那毫无疑问就是:“<strong>拓宽</strong>”。虽然 iOS  还没有达到炉火纯青的地步，但我还是义无反顾的开始了横向拓宽。我相信一个人才的最大价值，不是做好某一个具体的小需求(这是前提)，而是站在更高的角度做更大的事。</p>
<p>16 年技术栈拓展中，最大的三个收获应该是前端、Python 和安卓。然而考虑到与工作相结合，我想前端技术暂时可以放一放，重点学习 Python 和安卓也许会对 KPI 更加有利。</p>
<p>当然，好的书还是要读的。博客可以解释清楚某一个问题，而好书可以解释清楚某一个领域。在 Server 方面，李智慧的 《大型网站技术架构》 可以算作一本非常优秀的入门版书籍，介绍了诸多常见的属于和概念。而《计算机程序的构造和解释》(SICP) 作为 MIT 几十年来的教科书，是一本非常经典的介绍函数式编程的书籍。以上两本书推荐给感兴趣的读者。</p>
<p>过去的这一年成长了很多，从简书、微博几十个粉丝的小菜鸟，到几千粉丝的小 V，一路走来收获满满。不过我逐渐意识到越是大型的平台，普通用户的质量就越接近于行业平均水平。因此粉丝数、喜欢数并不值得参考，而且很多交流其实是浪费时间。因此在新的一年中我会减少社交平台上的互动，把有限的精力投入到线下的生活、工作、学习中去。</p>
<h1 id="2017-年的计划"><a href="#2017-年的计划" class="headerlink" title="2017 年的计划"></a>2017 年的计划</h1><p>在去年的年终总结里，我列出了五点计划:</p>
<ol>
<li>继续翻译优秀的英文文章。这一点做的不太好，虽然有幸加入了 SwiftGG 并翻译了一些 Swift 文章，但是总的来说数量还不够。不过考虑到还有非常多要做的事，翻译文章的性价比似乎就不太高了，所以暂时搁浅。</li>
<li>阅读优秀的博文。objc.cn 的文章在带着读，由于掌握了 Google 搜索， 所以再也不会像去年一样看 CSDN 了，从这一点来说，第二个目标算是圆满完成。</li>
<li>技术与基础。今年学习了 GCD、Runloop、Runtime、锁、Cocoapods、React Native 等技术，算是加深了技术深度，</li>
<li>读书。读完了 《图解 TCP/IP 》、《剑指 Offer》、《大型网站技术架构》、《计算机程序的构造与解释》，双十一还买(挖)了不少书(坑)。</li>
<li>实习。在贴吧和凤巢的日子里，小组里的各位同事一直在帮助我成长，我的每一丝进步都要感谢他们的帮助。</li>
</ol>
<p>总的来说 16 年的计划圆满完成了，在新的一年里我为自己制定了几个小目标:</p>
<ol>
<li>业务: 也许业务没有技术重要，但是没有业务的积累，再厉害的技术也只会浪费时间，甚至带来负面作用。踏入工作岗位后，我希望在 2017 年更加深入的理解团队业务，更好的融入团队的交流协作中。</li>
<li>读书: 双十一买了十几本书，目前看来优先级最高的是《七周七并发模型》和 《改善  Python 程序的 91 个建议》，如果有空的话 《Java 编程思想》和 《Effective Java》、《Android 开发艺术探索》也在计划中。</li>
<li>技术: 所谓的全栈工程师，或者 T 型人才并不是全干工程师，每一门技术必须掌握到一定深度。因此在跨界时切忌自我麻痹，不能总以“我是新手”为理由来安慰自己。我希望在新的一年里在 Python 和 Android 方面达到一定深度，以工作为标准来要求自己。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时光飞逝，一转眼已经是一年过去了， 去年的今天我写下了第一篇年度总结：&lt;a href=&quot;http://www.jianshu.com/p/fe529a7e83a0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一个普通iOS开发者的2015大总结&lt;/a&gt;。
    
    </summary>
    
    
      <category term="总结分享" scheme="http://fullstack.blog/tags/%E6%80%BB%E7%BB%93%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 代理服务器技术选型之旅</title>
    <link href="http://fullstack.blog/2016/12/30/HTTP-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B9%8B%E6%97%85/"/>
    <id>http://fullstack.blog/2016/12/30/HTTP-代理服务器技术选型之旅/</id>
    <published>2016-12-30T11:10:14.000Z</published>
    <updated>2016-12-30T11:10:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久不写博客了，在元旦到来前水一篇文章，聊聊我在实现代理服务器的过程中遇到的一些坑，同时祝各位读者新年快乐。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>长期以来，贴吧开发人员多，业务耦合大，需求变化频繁，因此容易产生 bug。而我所负责的广告相关业务，和 UI 密切相关，一旦因为某种原因(甚至是被别人改了代码)产生了 bug，必然大幅度影响广告收入。</p>
<p>解决问题的一种方法在于频繁的测试，既然避免不了代码层面的耦合，那总是可以通过定时的检查来避免问题。所以我们维护了一组核心 case，密切关注最核心的功能。选择核心 case 实际上是在覆盖面和测试成本之间的权衡，然而多个 case 有不同的测试步骤，测试效率始终难以提高。</p>
<p>因此，我们的目标是建立一个代理服务器，<strong>能够在运行时把任何包(包括线上包)的数据改成我希望的样子</strong>。换句话说，这个代理服务器也可以理解为一个私服，它能够获得客户端的请求数据并作出修改，也可以获得服务端的响应数据并做修改。</p>
<h1 id="代理服务器工作模型"><a href="#代理服务器工作模型" class="headerlink" title="代理服务器工作模型"></a>代理服务器工作模型</h1><p>在早期版本中，我们选择了简单的 HTTP 协议。这种选择对技术的要求最低，我们自己实现了一个代理服务器，开启 socket，监听端口，然后将客户端的请求发送给服务器，再把服务器的返回数据传回客户端。这种模式也被称为:“中间人模式”(MITM: Man In The Middle)。</p>
<p>虽然道理很简单，但实现起来还是有些地方要注意。首先，当 socket 接受数据后，应该新开一个进程/线程 进行处理。既然涉及到新的进程/线程，就一定要注意它的释放时机，否则会导致内存无限制增加。</p>
<p>其次，对于 <code>socket</code> 来说，它并没有等待函数，也就是说我无从得知何时有数据可读，因此这个艰巨的任务就交给了 <code>select</code>。我们把需要监听的 socket 对象作为参数传入其中，函数会一直阻塞，直到有可读、可写的对象，或者达到超时时间。</p>
<p><code>Keep-Alive</code> 字段可以复用 TCP 连接，是一种常见的 HTTP 协议的优化方式，在 HTTP 1.1 中已经是默认选项。填写这个字段后，Server 返回的数据可能是分批次的，这样能够改善用户体验，但也会增加代理服务器的实现难度。所以代理服务器在作为客户端，向真正服务器请求数据时，应该删除这个字段。</p>
<p>由于整套流程都是自己实现，因此可以比较容易的 HOOK 住上下行数据并做修改。只有注意在接收到全部数据后再做修改即，整个流程可以用下图简单表示:</p>
<p><img src="https://o8ouygf5v.qnssl.com/1483087878.png" alt="代理服务器的工作模式"></p>
<p>当时做完这一套东西以后，我在团队内部做了一次分享， 感兴趣的读者可以去 <a href="http://images.bestswifter.com/Proxy%202.key" target="_blank" rel="external">http://images.bestswifter.com/Proxy%202.key</a> 下载 PPT。</p>
<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>由于长连接基于 TCP，不用每次新建连接，也省略了不必要的 HTTP 报文头部，效率明显优于 HTTP。所以各大公司基本上选择了长连接作为实际生产环境下的连接方式。然而由于不熟悉 WebSocket 协议，并且我们依然支持短连接，所以代理服务器最终选择了 HTTP 协议。</p>
<p>要想实现这一点， 就得在应用启动时，模拟后台向客户端发送一段控制信息，强制客户端选择 HTTP 请求。这样一来，即使是线上包也可以走代理服务器。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>由于苹果强制要求使用 HTTPS，虽然已经延期，但也是明年的趋势。考虑到后续的使用，我们决定对之前实现的代理服务器进行升级。由于 HTTPS 涉及到请求协议的解析，以及加密解密和证书管理，上述自研方案很难 hold 住。经过一番调研，最后选择了一个比较知名的开源库 <a href="https://github.com/mitmproxy/mitmproxy" target="_blank" rel="external">mitmproxy</a>。</p>
<h1 id="Mitmproxy"><a href="#Mitmproxy" class="headerlink" title="Mitmproxy"></a>Mitmproxy</h1><p>选择这个库最主要的理由是它直接支持 HTTPS，不过没有中文文档，国内的使用相对来说比较少，所以在接入的时候可能会略花一点时间。</p>
<p>这是一个 python 库， 首先要安装 <code>virtualenv</code>，如果本地没装的话输入: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenv</div></pre></td></tr></table></figure>
<p>安装好了以后，进入 <code>mitmproxy/venv3.5/bin</code> 文件夹输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> ./active</div></pre></td></tr></table></figure>
<p>这样就可以启用 virtualenv 环境了。</p>
<h2 id="Hook-脚本"><a href="#Hook-脚本" class="headerlink" title="Hook 脚本"></a>Hook 脚本</h2><p>这个库可以理解为命令行中可交互版本的 Charles，不过我并不打算用它的这个功能。因为我的需求主要是利用脚本来 Hook 请求， 所以我选择了 mitmdump 这个工具。使用它的时候可以指定脚本:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mitmdump <span class="_">-s</span> <span class="string">"xxx.py"</span></div></pre></td></tr></table></figure>
<p>脚本也很简单，我们可以重写 <code>requeest</code> 或者 <code>receive</code> 函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(flow)</span>:</span></div><div class="line">        flow.response.content = <span class="string">"&lt;p&gt;hello world&lt;/p&gt;"</span></div></pre></td></tr></table></figure>
<p>运行脚本以后，把手机的代理设为本机 ip 地址，端口号改为 8080，然后用手机浏览器打开 <a href="http://mitm.it/" target="_blank" rel="external">http://mitm.it/</a>，如果一切配置顺利，你会看到证书的安装界面。</p>
<p>安装好证书后，用手机访问任何一个网站(包括 HTTPS)，你应该都会看到一个小小的 <code>hello world</code>，至此所有的配置就完成了。</p>
<h2 id="bug-修改"><a href="#bug-修改" class="headerlink" title="bug 修改"></a>bug 修改</h2><p>这个开源库有一个很严重的 bug，在解析 multipart 类型的数据时可能会发生。它使用了 <code>splitline</code> 方法来分割换行符，然而如果数据中有 <code>\n</code> 的话，就会因此丢失。很不幸的是，很多 protobuf 编码后的数据都有 <code>\n</code>，一旦丢失就会导致解析失败。</p>
<p>如果你不幸遇到了和我一样的坑，可以把相关代码改成我的版本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> content.split(<span class="string">b"--"</span> + boundary):</div><div class="line">    parts = i.split(<span class="string">b'\r\n\r\n'</span>, <span class="number">2</span>)</div><div class="line">    <span class="keyword">if</span> len(parts) &gt; <span class="number">1</span> <span class="keyword">and</span> parts[<span class="number">0</span>][<span class="number">0</span>:<span class="number">2</span>] != <span class="string">b"--"</span>:</div><div class="line">        match = rx.search(parts[<span class="number">0</span>])</div><div class="line">        <span class="keyword">if</span> match:</div><div class="line">            key = match.group(<span class="number">1</span>)</div><div class="line">            value = parts[<span class="number">1</span>][<span class="number">0</span>:len(parts[<span class="number">1</span>])<span class="number">-2</span>] <span class="comment"># Remove last \r\n</span></div><div class="line">            r.append((key, value))</div></pre></td></tr></table></figure>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>到了这一步，基本上已经成功实现支持 HTTPS 的代理服务器了。后续要处理的可能就是解析 protobuf，完善业务代码等等琐碎的事情，只要小心谨慎，基本上不会有问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久不写博客了，在元旦到来前水一篇文章，聊聊我在实现代理服务器的过程中遇到的一些坑，同时祝各位读者新年快乐。&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;长期以来，贴吧开
    
    </summary>
    
    
      <category term="python" scheme="http://fullstack.blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>该死的 XML in Android</title>
    <link href="http://fullstack.blog/2016/12/12/%E8%AF%A5%E6%AD%BB%E7%9A%84-XML-in-Android/"/>
    <id>http://fullstack.blog/2016/12/12/该死的-XML-in-Android/</id>
    <published>2016-12-12T10:19:15.000Z</published>
    <updated>2016-12-12T13:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然大三曾经短暂的接触 Android，但都只是囫囵吞枣，仅仅停留在调用 API 和开源库完成效果的程度上。既然真的要开始搞 Android，还是有必要刨根问底一下的。</p>
<p>作为入门，最近开始看 Google 的 <a href="https://developer.android.com/training/index.html" target="_blank" rel="external">Android Training</a>。最简单的肯定是创建一个 Hello World 工程，不过在写 LinearLayout 的时候，我发现一个比较奇怪的问题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>XML 文件中的前两行代码似乎很啰嗦，定义了两个 <code>xmlns</code> 和一长串没有意义的 URL。</p>
<p>实际上这里的 <code>xmlns</code> 指的是 XML 中的命名空间（namespace）概念。比如这里的 <code>android:layout_width</code> 属性，它就是 <code>android</code> 命名空间下的属性。如果没有命名空间的约束，整个 XML 中就不能出现重复的属性，事情就会很麻烦。</p>
<p>除了安卓默认提供的命名空间和控制 UI 样式的属性外，有时候，我们还可以自定义命名空间和属性，比如对于某个颜色来说，我希望它在普通模式和夜间模式下具有不同的样式，但对使用者完全透明（即对外只有一个颜色名）。</p>
<p>此时，就可以自定义一个 <code>app:bg_color</code>。要做到这一点，我们需要实现 <code>LayoutInflater.Factory</code> 接口并实现 <code>onCreateView</code> 方法。在将 XML 转化（inflate）为 View 的时候，实际上就是读取 XML 树中的各种属性和值，而 <code>onCreateView</code> 方法可以理解为这一过程的 Hook。</p>
<p>除此以外，我们也可以简单的添加几个常用的属性，<a href="http://stackoverflow.com/questions/2695646/declaring-a-custom-android-ui-element-using-xml" target="_blank" rel="external">这篇文章</a> 详细讲述了实现过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然大三曾经短暂的接触 Android，但都只是囫囵吞枣，仅仅停留在调用 API 和开源库完成效果的程度上。既然真的要开始搞 Android，还是有必要刨根问底一下的。&lt;/p&gt;
&lt;p&gt;作为入门，最近开始看 Google 的 &lt;a href=&quot;https://develope
    
    </summary>
    
    
      <category term="Android" scheme="http://fullstack.blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Drawable 复用</title>
    <link href="http://fullstack.blog/2016/12/08/Drawable-%E5%A4%8D%E7%94%A8/"/>
    <id>http://fullstack.blog/2016/12/08/Drawable-复用/</id>
    <published>2016-12-08T10:16:35.000Z</published>
    <updated>2016-12-08T10:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复用-Drawable"><a href="#复用-Drawable" class="headerlink" title="复用 Drawable"></a>复用 Drawable</h1><p><strong>Drawable</strong> 表示了一类通用的，可被绘制的资源。与View 的主要区别就在于，Drawable 并不会响应事件。</p>
<h2 id="Drawable-的复用机制"><a href="#Drawable-的复用机制" class="headerlink" title="Drawable 的复用机制"></a>Drawable 的复用机制</h2><p>Drawable 的使用非常方便，系统框架内部有 700 多种默认的 Drawable。当我们新建一个 button 时，实际上它的背景就是一个默认的 Drawable。</p>
<p>每个 Drawable 都有一个 <code>constant state</code>，这个 state 中保存了Drawable 所有的关键信息。比如对于 Button 来说，其中就保存了用于展示的 Bitmap。</p>
<p>由于 Drawable 非常常用，为了优化性能（其实主要就是节省内存），所有的 Drawable 都共享同一个 <code>constant state</code>。</p>
<h2 id="重用-state"><a href="#重用-state" class="headerlink" title="重用 state"></a>重用 state</h2><p>这种优化有时候也会导致一些问题，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Drawable star = context.getResources().getDrawable(R.drawable.star);</div><div class="line"><span class="keyword">if</span> (book.isFavorite()) &#123;</div><div class="line">  star.setAlpha(<span class="number">255</span>); <span class="comment">// opaque</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  star.setAlpha(<span class="number">70</span>); <span class="comment">// translucent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有多个 book 对象构成一个 <code>listview</code>，我们希望的效果是喜欢的图书，星星是亮的，否则是灭的。但如果使用上述代码就会发现，所有星星的颜色都是一样的。</p>
<p>这是因为 alpha 信息保存在 constant state 中，所有的星星都共享这个 state，对任何一个的修改都会影响其他所有的。</p>
<p>解决方案是使用 <code>mutate</code> 方法。这个方法会返回同一个 Drawable 对象，但是其中的 state 被复制了，这样对 state 的修改就互不干扰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Drawable star = context.getResources().getDrawable(R.drawable.star);</div><div class="line"><span class="keyword">if</span> (book.isFavorite()) &#123;</div><div class="line">  star.mutate().setAlpha(<span class="number">255</span>); <span class="comment">// opaque</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  star.mutate().setAlpha(<span class="number">70</span>); <span class="comment">// translucent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重用-bitmap"><a href="#重用-bitmap" class="headerlink" title="重用 bitmap"></a>重用 bitmap</h2><p>不过有时候仅仅复制 state 还不够，因为所有的 state 还会共享同一个 Bitmap，也就是说调用 <code>mutate()</code> 方法并不会复制 Bitmap。</p>
<p>假设我们有两个 TextView 需要设置圆角，我们可以首先创建一个 <code>GradientDrawable</code> 对象并设置圆角：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GradientDrawable gd = <span class="keyword">new</span> GradientDrawable();</div><div class="line">gd.setColor(Color.parseColor(<span class="string">"#000000"</span>));</div><div class="line">gd.setCornerRadius(context.getResources().getDimension(R.dimen.ds4));</div><div class="line">gd.setStroke(<span class="number">1</span>, Color.parseColor(<span class="string">"#000000"</span>));</div></pre></td></tr></table></figure>
<p>接下来，任何需要设置圆角背景的 TextView 都可以调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textview.setBackgroundDrawable(gd);</div></pre></td></tr></table></figure>
<p>然而由于 Drawable 对象的 Bitmap 会被复用，所以即使我们调用了 <code>mutate()</code> 方法，所有的 TextView 的圆角背景区域依然都会以最后一个 TextView 的大小为准。</p>
<p>在这种情况下，我们可以通过 <code>constant state</code> 创建一个新的 Drawable 对象，此时这两个完全不同的对象会使用不用的 Bitmap，也就避免了上述问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textview.setBackgroundDrawable(gd.getConstantState().newDrawable());</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;复用-Drawable&quot;&gt;&lt;a href=&quot;#复用-Drawable&quot; class=&quot;headerlink&quot; title=&quot;复用 Drawable&quot;&gt;&lt;/a&gt;复用 Drawable&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Drawable&lt;/strong&gt; 表示了一类通用的
    
    </summary>
    
    
      <category term="Android" scheme="http://fullstack.blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://fullstack.blog/2016/11/18/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://fullstack.blog/2016/11/18/新的开始/</id>
    <published>2016-11-18T10:53:53.000Z</published>
    <updated>2016-12-08T12:55:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习了两年 iOS 以后，我决定开始横向拓展，也就是所谓的全栈工程师（不是全干工程师！），或者说，叫 T 型人才听上去更高端。作出这样的改变主要是由内在原因和外在原因共同导致的。</p>
<h1 id="内因"><a href="#内因" class="headerlink" title="内因"></a>内因</h1><p>首先，经过了两年的学习，不管是基础的 UI 控件，还是 <code>UITableView</code> 的各种调优，基本上都达到了掌握的程度。在准备面试和后来与同行交流的过程中，也对 ARC、Block、Rumtime、Runloop、GCD、Thread 等底层概念和源码有了一定的理解。</p>
<p>因此，我逐渐发现对于个人来说，如果再从事 UI 和 功能点的开发，个人的技术水平将很难有质的飞跃。当然，这也是因人而异，如果是对编译器、C/C++ 等底层知识感兴趣，完全可以深入挖掘，还有非常多值得学习的内容。</p>
<p>不过我本来就是对底层知识不感兴趣的人，我尤其反对面试时过度拿毫无用处的“底层知识”来为难面试者。我所理解的有用的底层知识，应该是指那些经常用到，但一般人说不清楚，而且一旦说不清楚就会影响编程的那些知识。</p>
<p>比如常见的 GCD 何时发生死锁，ARC 下的内存管理，Block 的实现原理、Runloop 与定时器等。这些底层知识如果不详细掌握，将会在实际开发中写出无法维护的代码，引入匪夷所思的 bug。</p>
<p>然而，计算机的发展趋势向来就是不断封装底层的实现细节。从早期的手写机器码，到后来的链接器处理重定位问题，再到 C 语言和现代的编程语言，无一不是屏蔽底层信息，从而提高开发者的效率。因此，过度的追求技术细节在我看来是一种浪费时间的行为，只有站在前人的肩膀上才能走的更远。</p>
<h1 id="外因"><a href="#外因" class="headerlink" title="外因"></a>外因</h1><p>自从三月份参加工作后，我陆陆续续接触了很多非 iOS 方面的知识。从调研 React Native、JSPatch 的实现原理，到学习 Python、Ruby、Shell 脚本语言，以及目前在做的 HTTP 代理、Android 开发，我见识到了很多新的技术和思想。我开始意识到，很多思想在不同平台都有，只不过是换了个名字和上下文。一个有能力、有经验、常思考的开发者可以非常容易的从一个平台转到一个类似的平台，靠的就是他对语言、业务的理解。</p>
<p>当然，快速入门别的语言和业务并不是我的目标，我也时刻提醒自己不要沦为全干工程师。了解多个语言、掌握多种技术的目的，并不是为了自己能同时干好几个工种，而是能够吸取各个平台的长处。</p>
<p>一方面，自己对技术的理解可以因此得到增强。比如说同样是哈希，客户端（Java 和 Objective-C）看重的是对象一致性，而不关心重哈希的性能。Java 作为一种服务端语言，提供了自动转红黑树的机制，提高了极端情况下的性能。而 Redis 中没有对象等同性的概念，所以它提供了统一的哈希函数，并实现了增量重哈希。而在分布式网站架构中，我们又使用一致性哈希的技术来处理哈希冲突。</p>
<p>可见，不同的场景下对于同一问题通常会作出取舍，但是多方面了解解决问题的思路有助于优化改善我们今后自己在处理其他问题时的设计方案，从而可以更加接近问题的本质并作出更好的决策。</p>
<p>另一方面，多种技术一旦合并起来，就能形成强大的战斗力。今年非常火的 JSPatch、RN、Weex 足以证明。</p>
<h1 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h1><p>说了这么多废话，归根结底还是希望自己的未来能够更光明（说得再简单暴力点就是工资高）。我相信绝大多数人工作的目的都是为了工资，那么就从企业的角度聊聊。</p>
<p>首先，企业雇人的终极目的也是唯一目的就是赚钱。只有为企业赚到更多的钱，才有可能拿到更高的工资。因此支付我们工资的，不是技术而是企业利润，我们仅仅是通过自己的技术为企业获得利润。从这一点上看，我们只要会写 UI 和功能，就可以拿工资了。</p>
<p>实际上，了解一定程度的底层知识可以避免 bug、提高开发效率。因为一旦发生 bug，或者开发效率低下，企业的收益必然受到严重影响。因此，适当的掌握底层技术可以获得更高的工资。</p>
<p>然而，如果一味地追求底层技术，就意味着相当多的知识难以在实际生产中用上，可选择的就业面也就越来越窄，其中相当一部分技术如果用来炫技还行，但对于利润的贡献其实并不大。</p>
<p>其次，企业其实非常需要优秀的技术管理者。一个既精通前端、又精通客户端的技术经理，在开发 Hybrid 应用时具有相当大的优势。同样的，既精通客户端，又精通服务端的技术经理可以在网络通信的过程中发挥自己的长<br>处。</p>
<p>更可怕的是， 如果不能站在对方的立场上思考问题，或者不了解对方的开发模式，就会浪费相当多的时间在沟通、交流上，一旦设计错误还会造成难以挽回的损失。</p>
<p>因此，无论技术如何变迁，掌握多项技能，能站在一定高度上综合的思考问题，拥有良好沟通、设计能力的技术管理者，一直会是公司最宝贵的人才。</p>
<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><p>在这个博客里，我会写非常杂的内容，包括但不局限于 Python、Android、Java、HTTP、JavaScript ……。文章会分为两种类型，一种是对某个问题的简单总结，更新频率较高。另一种则是对某个话题深入全面的思考，更新频率<br>较低。</p>
<p>同时，作为一名 iOS 开发者，iOS 开发是我安身立命的本钱，因此<a href="https://bestswifter.com" target="_blank" rel="external">旧的博客</a> 将会持续维护下去，主要讨论 iOS、Objectie-C 和 Swift 技术。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习了两年 iOS 以后，我决定开始横向拓展，也就是所谓的全栈工程师（不是全干工程师！），或者说，叫 T 型人才听上去更高端。作出这样的改变主要是由内在原因和外在原因共同导致的。&lt;/p&gt;
&lt;h1 id=&quot;内因&quot;&gt;&lt;a href=&quot;#内因&quot; class=&quot;headerlin
    
    </summary>
    
    
  </entry>
  
</feed>
