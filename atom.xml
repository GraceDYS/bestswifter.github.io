<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全栈养成计划</title>
  <subtitle>每天学点新知识~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fullstack.blog/"/>
  <updated>2016-12-12T13:01:37.000Z</updated>
  <id>http://fullstack.blog/</id>
  
  <author>
    <name>Fullstack</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>该死的 XML in Android</title>
    <link href="http://fullstack.blog/2016/12/12/%E8%AF%A5%E6%AD%BB%E7%9A%84-XML-in-Android/"/>
    <id>http://fullstack.blog/2016/12/12/该死的-XML-in-Android/</id>
    <published>2016-12-12T10:19:15.000Z</published>
    <updated>2016-12-12T13:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然大三曾经短暂的接触 Android，但都只是囫囵吞枣，仅仅停留在调用 API 和开源库完成效果的程度上。既然真的要开始搞 Android，还是有必要刨根问底一下的。</p>
<p>作为入门，最近开始看 Google 的 <a href="https://developer.android.com/training/index.html" target="_blank" rel="external">Android Training</a>。最简单的肯定是创建一个 Hello World 工程，不过在写 LinearLayout 的时候，我发现一个比较奇怪的问题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>XML 文件中的前两行代码似乎很啰嗦，定义了两个 <code>xmlns</code> 和一长串没有意义的 URL。</p>
<p>实际上这里的 <code>xmlns</code> 指的是 XML 中的命名空间（namespace）概念。比如这里的 <code>android:layout_width</code> 属性，它就是 <code>android</code> 命名空间下的属性。如果没有命名空间的约束，整个 XML 中就不能出现重复的属性，事情就会很麻烦。</p>
<p>除了安卓默认提供的命名空间和控制 UI 样式的属性外，有时候，我们还可以自定义命名空间和属性，比如对于某个颜色来说，我希望它在普通模式和夜间模式下具有不同的样式，但对使用者完全透明（即对外只有一个颜色名）。</p>
<p>此时，就可以自定义一个 <code>app:bg_color</code>。要做到这一点，我们需要实现 <code>LayoutInflater.Factory</code> 接口并实现 <code>onCreateView</code> 方法。</p>
<p>除此以外，我们也可以简单的添加几个常用的属性，<a href="http://stackoverflow.com/questions/2695646/declaring-a-custom-android-ui-element-using-xml" target="_blank" rel="external">这篇文章</a> 详细讲述了实现过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然大三曾经短暂的接触 Android，但都只是囫囵吞枣，仅仅停留在调用 API 和开源库完成效果的程度上。既然真的要开始搞 Android，还是有必要刨根问底一下的。&lt;/p&gt;
&lt;p&gt;作为入门，最近开始看 Google 的 &lt;a href=&quot;https://develope
    
    </summary>
    
    
      <category term="Android" scheme="http://fullstack.blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Drawable 复用</title>
    <link href="http://fullstack.blog/2016/12/08/Drawable-%E5%A4%8D%E7%94%A8/"/>
    <id>http://fullstack.blog/2016/12/08/Drawable-复用/</id>
    <published>2016-12-08T10:16:35.000Z</published>
    <updated>2016-12-08T10:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复用-Drawable"><a href="#复用-Drawable" class="headerlink" title="复用 Drawable"></a>复用 Drawable</h1><p><strong>Drawable</strong> 表示了一类通用的，可被绘制的资源。与View 的主要区别就在于，Drawable 并不会响应事件。</p>
<h2 id="Drawable-的复用机制"><a href="#Drawable-的复用机制" class="headerlink" title="Drawable 的复用机制"></a>Drawable 的复用机制</h2><p>Drawable 的使用非常方便，系统框架内部有 700 多种默认的 Drawable。当我们新建一个 button 时，实际上它的背景就是一个默认的 Drawable。</p>
<p>每个 Drawable 都有一个 <code>constant state</code>，这个 state 中保存了Drawable 所有的关键信息。比如对于 Button 来说，其中就保存了用于展示的 Bitmap。</p>
<p>由于 Drawable 非常常用，为了优化性能（其实主要就是节省内存），所有的 Drawable 都共享同一个 <code>constant state</code>。</p>
<h2 id="重用-state"><a href="#重用-state" class="headerlink" title="重用 state"></a>重用 state</h2><p>这种优化有时候也会导致一些问题，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Drawable star = context.getResources().getDrawable(R.drawable.star);</div><div class="line"><span class="keyword">if</span> (book.isFavorite()) &#123;</div><div class="line">  star.setAlpha(<span class="number">255</span>); <span class="comment">// opaque</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  star.setAlpha(<span class="number">70</span>); <span class="comment">// translucent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有多个 book 对象构成一个 <code>listview</code>，我们希望的效果是喜欢的图书，星星是亮的，否则是灭的。但如果使用上述代码就会发现，所有星星的颜色都是一样的。</p>
<p>这是因为 alpha 信息保存在 constant state 中，所有的星星都共享这个 state，对任何一个的修改都会影响其他所有的。</p>
<p>解决方案是使用 <code>mutate</code> 方法。这个方法会返回同一个 Drawable 对象，但是其中的 state 被复制了，这样对 state 的修改就互不干扰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Drawable star = context.getResources().getDrawable(R.drawable.star);</div><div class="line"><span class="keyword">if</span> (book.isFavorite()) &#123;</div><div class="line">  star.mutate().setAlpha(<span class="number">255</span>); <span class="comment">// opaque</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  star.mutate().setAlpha(<span class="number">70</span>); <span class="comment">// translucent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重用-bitmap"><a href="#重用-bitmap" class="headerlink" title="重用 bitmap"></a>重用 bitmap</h2><p>不过有时候仅仅复制 state 还不够，因为所有的 state 还会共享同一个 Bitmap，也就是说调用 <code>mutate()</code> 方法并不会复制 Bitmap。</p>
<p>假设我们有两个 TextView 需要设置圆角，我们可以首先创建一个 <code>GradientDrawable</code> 对象并设置圆角：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GradientDrawable gd = <span class="keyword">new</span> GradientDrawable();</div><div class="line">gd.setColor(Color.parseColor(<span class="string">"#000000"</span>));</div><div class="line">gd.setCornerRadius(context.getResources().getDimension(R.dimen.ds4));</div><div class="line">gd.setStroke(<span class="number">1</span>, Color.parseColor(<span class="string">"#000000"</span>));</div></pre></td></tr></table></figure>
<p>接下来，任何需要设置圆角背景的 TextView 都可以调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textview.setBackgroundDrawable(gd);</div></pre></td></tr></table></figure>
<p>然而由于 Drawable 对象的 Bitmap 会被复用，所以即使我们调用了 <code>mutate()</code> 方法，所有的 TextView 的圆角背景区域依然都会以最后一个 TextView 的大小为准。</p>
<p>在这种情况下，我们可以通过 <code>constant state</code> 创建一个新的 Drawable 对象，此时这两个完全不同的对象会使用不用的 Bitmap，也就避免了上述问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textview.setBackgroundDrawable(gd.getConstantState().newDrawable());</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;复用-Drawable&quot;&gt;&lt;a href=&quot;#复用-Drawable&quot; class=&quot;headerlink&quot; title=&quot;复用 Drawable&quot;&gt;&lt;/a&gt;复用 Drawable&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Drawable&lt;/strong&gt; 表示了一类通用的
    
    </summary>
    
    
      <category term="Android" scheme="http://fullstack.blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://fullstack.blog/2016/11/18/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://fullstack.blog/2016/11/18/新的开始/</id>
    <published>2016-11-18T10:53:53.000Z</published>
    <updated>2016-12-08T12:55:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习了两年 iOS 以后，我决定开始横向拓展，也就是所谓的全栈工程师（不是全干工程师！），或者说，叫 T 型人才听上去更高端。作出这样的改变主要是由内在原因和外在原因共同导致的。</p>
<h1 id="内因"><a href="#内因" class="headerlink" title="内因"></a>内因</h1><p>首先，经过了两年的学习，不管是基础的 UI 控件，还是 <code>UITableView</code> 的各种调优，基本上都达到了掌握的程度。在准备面试和后来与同行交流的过程中，也对 ARC、Block、Rumtime、Runloop、GCD、Thread 等底层概念和源码有了一定的理解。</p>
<p>因此，我逐渐发现对于个人来说，如果再从事 UI 和 功能点的开发，个人的技术水平将很难有质的飞跃。当然，这也是因人而异，如果是对编译器、C/C++ 等底层知识感兴趣，完全可以深入挖掘，还有非常多值得学习的内容。</p>
<p>不过我本来就是对底层知识不感兴趣的人，我尤其反对面试时过度拿毫无用处的“底层知识”来为难面试者。我所理解的有用的底层知识，应该是指那些经常用到，但一般人说不清楚，而且一旦说不清楚就会影响编程的那些知识。</p>
<p>比如常见的 GCD 何时发生死锁，ARC 下的内存管理，Block 的实现原理、Runloop 与定时器等。这些底层知识如果不详细掌握，将会在实际开发中写出无法维护的代码，引入匪夷所思的 bug。</p>
<p>然而，计算机的发展趋势向来就是不断封装底层的实现细节。从早期的手写机器码，到后来的链接器处理重定位问题，再到 C 语言和现代的编程语言，无一不是屏蔽底层信息，从而提高开发者的效率。因此，过度的追求技术细节在我看来是一种浪费时间的行为，只有站在前人的肩膀上才能走的更远。</p>
<h1 id="外因"><a href="#外因" class="headerlink" title="外因"></a>外因</h1><p>自从三月份参加工作后，我陆陆续续接触了很多非 iOS 方面的知识。从调研 React Native、JSPatch 的实现原理，到学习 Python、Ruby、Shell 脚本语言，以及目前在做的 HTTP 代理、Android 开发，我见识到了很多新的技术和思想。我开始意识到，很多思想在不同平台都有，只不过是换了个名字和上下文。一个有能力、有经验、常思考的开发者可以非常容易的从一个平台转到一个类似的平台，靠的就是他对语言、业务的理解。</p>
<p>当然，快速入门别的语言和业务并不是我的目标，我也时刻提醒自己不要沦为全干工程师。了解多个语言、掌握多种技术的目的，并不是为了自己能同时干好几个工种，而是能够吸取各个平台的长处。</p>
<p>一方面，自己对技术的理解可以因此得到增强。比如说同样是哈希，客户端（Java 和 Objective-C）看重的是对象一致性，而不关心重哈希的性能。Java 作为一种服务端语言，提供了自动转红黑树的机制，提高了极端情况下的性能。而 Redis 中没有对象等同性的概念，所以它提供了统一的哈希函数，并实现了增量重哈希。而在分布式网站架构中，我们又使用一致性哈希的技术来处理哈希冲突。</p>
<p>可见，不同的场景下对于同一问题通常会作出取舍，但是多方面了解解决问题的思路有助于优化改善我们今后自己在处理其他问题时的设计方案，从而可以更加接近问题的本质并作出更好的决策。</p>
<p>另一方面，多种技术一旦合并起来，就能形成强大的战斗力。今年非常火的 JSPatch、RN、Weex 足以证明。</p>
<h1 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h1><p>说了这么多废话，归根结底还是希望自己的未来能够更光明（说得再简单暴力点就是工资高）。我相信绝大多数人工作的目的都是为了工资，那么就从企业的角度聊聊。</p>
<p>首先，企业雇人的终极目的也是唯一目的就是赚钱。只有为企业赚到更多的钱，才有可能拿到更高的工资。因此支付我们工资的，不是技术而是企业利润，我们仅仅是通过自己的技术为企业获得利润。从这一点上看，我们只要会写 UI 和功能，就可以拿工资了。</p>
<p>实际上，了解一定程度的底层知识可以避免 bug、提高开发效率。因为一旦发生 bug，或者开发效率低下，企业的收益必然受到严重影响。因此，适当的掌握底层技术可以获得更高的工资。</p>
<p>然而，如果一味地追求底层技术，就意味着相当多的知识难以在实际生产中用上，可选择的就业面也就越来越窄，其中相当一部分技术如果用来炫技还行，但对于利润的贡献其实并不大。</p>
<p>其次，企业其实非常需要优秀的技术管理者。一个既精通前端、又精通客户端的技术经理，在开发 Hybrid 应用时具有相当大的优势。同样的，既精通客户端，又精通服务端的技术经理可以在网络通信的过程中发挥自己的长<br>处。</p>
<p>更可怕的是， 如果不能站在对方的立场上思考问题，或者不了解对方的开发模式，就会浪费相当多的时间在沟通、交流上，一旦设计错误还会造成难以挽回的损失。</p>
<p>因此，无论技术如何变迁，掌握多项技能，能站在一定高度上综合的思考问题，拥有良好沟通、设计能力的技术管理者，一直会是公司最宝贵的人才。</p>
<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><p>在这个博客里，我会写非常杂的内容，包括但不局限于 Python、Android、Java、HTTP、JavaScript ……。文章会分为两种类型，一种是对某个问题的简单总结，更新频率较高。另一种则是对某个话题深入全面的思考，更新频率<br>较低。</p>
<p>同时，作为一名 iOS 开发者，iOS 开发是我安身立命的本钱，因此<a href="https://bestswifter.com" target="_blank" rel="external">旧的博客</a> 将会持续维护下去，主要讨论 iOS、Objectie-C 和 Swift 技术。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习了两年 iOS 以后，我决定开始横向拓展，也就是所谓的全栈工程师（不是全干工程师！），或者说，叫 T 型人才听上去更高端。作出这样的改变主要是由内在原因和外在原因共同导致的。&lt;/p&gt;
&lt;h1 id=&quot;内因&quot;&gt;&lt;a href=&quot;#内因&quot; class=&quot;headerlin
    
    </summary>
    
    
  </entry>
  
</feed>
